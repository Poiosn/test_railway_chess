<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Chess Master â€” Premium Edition</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
<script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>

<style>
*{margin:0;padding:0;box-sizing:border-box}

/* ================= THEME ================= */
:root{
  --bg:linear-gradient(135deg,#020617,#0f172a);
  --glass:rgba(255,255,255,.08);
  --glass-strong:rgba(255,255,255,.14);
  --border:rgba(255,255,255,.18);
  --accent:#38bdf8;
  --accent2:#a78bfa;
  --success:#22c55e;
  --danger:#ef4444;
  --warning:#f59e0b;
  --text:#e5e7eb;
  --text-soft:#9ca3af;
}

/* ================= BODY ================= */
body{
  height:100vh;
  background:var(--bg);
  display:flex;
  justify-content:center;
  align-items:center;
  padding:8px;
  overflow:hidden;
  font-family:Inter,Segoe UI,sans-serif;
  color:var(--text);
  user-select:none;
}

/* ================= CONTAINER ================= */
.container{
  width:100%;
  max-width:1350px;
  max-height:calc(100vh - 16px);
  background:linear-gradient(180deg,rgba(255,255,255,.12),rgba(255,255,255,.04));
  backdrop-filter:blur(18px);
  border-radius:14px;
  border:1px solid var(--border);
  box-shadow:0 30px 90px rgba(0,0,0,.65);
  padding:6px;
  overflow-y:auto;
}

/* ================= HEADER ================= */
.header{
  text-align:center;
  position:relative;
  margin-bottom:6px;
}
.header h1{
  font-size:18px;
  font-weight:900;
  background:linear-gradient(90deg,var(--accent),var(--accent2));
  -webkit-background-clip:text;
  -webkit-text-fill-color:transparent;
}
.subtitle{
  font-size:9px;
  color:var(--text-soft);
}
.sound-toggle{
  position:absolute;
  right:6px;
  top:4px;
  width:28px;
  height:28px;
  border-radius:50%;
  display:flex;
  align-items:center;
  justify-content:center;
  cursor:pointer;
  background:var(--glass);
  border:1px solid var(--border);
}

/* ================= INFO BAR ================= */
.game-info-bar{
  display:flex;
  justify-content:center;
  padding:4px;
  border-radius:8px;
  background:var(--glass);
  border:1px solid var(--border);
  margin-bottom:6px;
  font-size:11px;
}

/* ================= LAYOUT ================= */
.game-layout{
  display:grid;
  grid-template-columns:1fr 280px;
  gap:10px;
}

/* ================= PLAYER CARDS ================= */
.player-card{
  display:flex;
  justify-content:space-between;
  align-items:center;
  padding:6px 10px;
  border-radius:10px;
  background:var(--glass);
  border:1px solid var(--border);
}
.player-card.black{
  background:linear-gradient(135deg,#020617,#020617);
}
.player-name-text{
  font-size:11px;
  font-weight:700;
}
.timer{
  font-size:11px;
  padding:4px 10px;
  border-radius:999px;
  background:rgba(0,0,0,.4);
  border:1px solid var(--border);
}
.timer.active{
  box-shadow:0 0 12px var(--accent);
}

/* ================= BOARD ================= */
.board-wrapper{
  max-width:450px;
  margin:0 auto;
  position:relative;
}
.chessboard{
  display:grid;
  grid-template-columns:repeat(8,1fr);
  aspect-ratio:1/1;
  border-radius:14px;
  overflow:hidden;
  border:2px solid #020617;
}
.square{
  display:flex;
  align-items:center;
  justify-content:center;
}
.square.light{background:#f1f5f9}
.square.dark{background:#94a3b8}
.square.selected{outline:3px solid var(--accent)}
.square.possible-move::after{
  content:"";
  width:30%;
  height:30%;
  background:rgba(56,189,248,.6);
  border-radius:50%;
}

/* ================= SIDEBAR ================= */
.sidebar{
  display:flex;
  flex-direction:column;
  gap:6px;
}
.card{
  background:var(--glass);
  border:1px solid var(--border);
  border-radius:10px;
  padding:6px;
}
.card-header{
  font-size:10px;
  font-weight:800;
  color:var(--accent);
  margin-bottom:6px;
}

/* ================= BUTTONS ================= */
.controls{
  display:grid;
  grid-template-columns:repeat(2,1fr);
  gap:6px;
}
.btn{
  border:none;
  border-radius:8px;
  padding:6px;
  font-size:9px;
  font-weight:800;
  cursor:pointer;
  color:#fff;
}
.btn-home{background:linear-gradient(135deg,#2563eb,#7c3aed)}
.btn-draw{background:linear-gradient(135deg,#f59e0b,#facc15)}
.btn-resign{background:linear-gradient(135deg,#ef4444,#dc2626);grid-column:span 2}
.btn-rematch{background:linear-gradient(135deg,#22c55e,#16a34a);grid-column:span 2}

/* ================= CHAT ================= */
#chatMessages{
  background:rgba(0,0,0,.25);
  border-radius:8px;
  padding:6px;
  font-size:9px;
  max-height:90px;
  overflow-y:auto;
}
.chat-input-area{
  display:flex;
  gap:4px;
}
#chatInput{
  flex:1;
  padding:5px;
  border-radius:8px;
  border:1px solid var(--border);
  background:rgba(0,0,0,.4);
  color:#fff;
}
</style>
</head>

<body>
<div class="container">

  <div class="header">
    <h1>â™Ÿ Chess Master</h1>
    <div class="subtitle">Premium Edition â€” Real-time Multiplayer</div>
    <div class="sound-toggle" id="soundToggle">ðŸ”Š</div>
  </div>

  <div id="loadingMessage" style="text-align:center;padding:40px;">
    <div style="font-size:40px">â™Ÿ</div>
    Connecting to gameâ€¦
  </div>

  <div id="game" style="display:none;">
    <div class="game-info-bar">
      <strong id="roomName">Room</strong>
    </div>

    <div class="game-layout">

      <div class="board-section">

        <div class="player-card black">
          <span id="blackPlayerName">Black</span>
          <div class="timer" id="blackTimer">5:00</div>
        </div>

        <div class="board-wrapper">
          <div class="chessboard" id="chessboard"></div>
          <div class="disconnect-overlay" id="disconnectOverlay"></div>
        </div>

        <div class="turn-indicator" id="turnIndicator">White to move</div>

        <div class="player-card">
          <span id="whitePlayerName">White</span>
          <div class="timer" id="whiteTimer">5:00</div>
        </div>

      </div>

      <div class="sidebar">

        <div class="card">
          <div class="card-header">Game Status</div>
          <div id="status"></div>
          <div id="messages"></div>
        </div>

        <div class="card">
          <div class="card-header">Move History</div>
          <div id="moveList"></div>
        </div>

        <div class="card">
          <div class="card-header">Controls</div>
          <div class="controls">
            <button class="btn btn-home" onclick="goHome()">Home</button>
            <button class="btn btn-draw" onclick="offerDraw()">Draw</button>
            <button class="btn btn-resign" onclick="resignGame()">Resign</button>
            <button class="btn btn-rematch" id="rematchBtn">Rematch</button>
          </div>
        </div>

        <div class="card">
          <div class="card-header">Live Chat</div>
          <div id="chatMessages"></div>
          <div class="chat-input-area">
            <input id="chatInput" placeholder="Type messageâ€¦" />
            <button class="btn btn-home" onclick="sendMessage()">Send</button>
          </div>
        </div>

      </div>
    </div>
  </div>
</div>


<script>
// ===== PARSE URL PARAMS =====
const params = new URLSearchParams(window.location.search);
const URL_ROOM = params.get("room");
const URL_NAME = params.get("name") || "Player";
const URL_TIME = parseInt(params.get("time")) || 300;
const URL_MODE = params.get("mode") || "friend";

if (!URL_ROOM) {
  alert("No room specified!");
  window.location.href = "/";
}

// ===== SOCKET CONNECTION =====
const socket = io();

// Enhanced socket connection logging
socket.on("connect", () => {
  console.log("âœ… Socket connected! ID:", socket.id);
});

socket.on("connect_error", (error) => {
  console.error("âŒ Socket connection error:", error);
  alert("Connection error! Check your internet connection.");
});

socket.on("disconnect", (reason) => {
  console.warn("âš ï¸ Socket disconnected:", reason);
});

socket.on("error", (error) => {
  console.error("âŒ Socket error:", error);
  if (error && error.message) {
    alert("Socket error: " + error.message);
  }
});

// ===== GAME STATE =====
let currentRoom = URL_ROOM;
let playerColor = null;
let playerName = URL_NAME;
let gameState = null;
let selectedSquare = null;
let possibleMoves = [];
let pendingPromotion = null;
let moveHistory = [];
let soundEnabled = true;
let lastMoveWasMine = false;
let lastMoveTime = 0;
let whiteSeconds = 0;
let blackSeconds = 0;
let timerInterval = null;
let pendingMoves = new Map();
let moveSequence = 0;
let disconnectInterval = null;
let isDragging = false;
let pendingUpdate = null;
let gameMode = URL_MODE || "friend";

function timeStringToSeconds(str) {
  if (!str || typeof str !== "string" || !str.includes(":")) return 0;
  const [m, s] = str.split(":").map(Number);
  return m * 60 + s;
}

function formatSeconds(sec) {
  sec = Math.max(0, Math.floor(sec));
  const m = Math.floor(sec / 60);
  const s = sec % 60;
  return `${m}:${s.toString().padStart(2, "0")}`;
}

function updateDisplayedTimers() {
  const whiteTimer = document.getElementById("whiteTimer");
  const blackTimer = document.getElementById("blackTimer");
  
  if (whiteTimer) whiteTimer.textContent = formatSeconds(whiteSeconds);
  if (blackTimer) blackTimer.textContent = formatSeconds(blackSeconds);
  
  if (gameState && !gameState.winner) {
    const activeColor = gameState.turn;
    if (whiteTimer) whiteTimer.classList.toggle("active", activeColor === "white");
    if (blackTimer) blackTimer.classList.toggle("active", activeColor === "black");
  } else {
    if (whiteTimer) whiteTimer.classList.remove("active");
    if (blackTimer) blackTimer.classList.remove("active");
  }
}

function startLocalTimer() {
  if (timerInterval) clearInterval(timerInterval);

  timerInterval = setInterval(() => {
    if (!gameState || gameState.winner || (gameState.isActive === false)) {
      clearInterval(timerInterval);
      return;
    }
    if (gameState.turn === "white" && whiteSeconds > 0) {
      whiteSeconds = Math.max(0, whiteSeconds - 1);
    } else if (gameState.turn === "black" && blackSeconds > 0) {
      blackSeconds = Math.max(0, blackSeconds - 1);
    }
    updateDisplayedTimers();
    if (whiteSeconds === 0 || blackSeconds === 0) {
      clearInterval(timerInterval);
    }
  }, 1000);
}

const sounds = {
  move: { freq: 400, duration: 0.1 },
  capture: { freq: 300, duration: 0.15 },
  check: { freq: 600, duration: 0.2 },
  win: { freq: 800, duration: 0.3 },
  notify: { freq: 500, duration: 0.1 }
};

let audioCtx = null;

function initAudio() {
  if (typeof window.AudioContext === 'undefined' && typeof window.webkitAudioContext === 'undefined') return;
  if (!audioCtx) {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  }
  if (audioCtx.state === 'suspended') {
    audioCtx.resume();
  }
}

function playSound(type) {
  if (!soundEnabled) return;
  try {
    initAudio();
    if (!audioCtx) return;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.connect(gain); 
    gain.connect(audioCtx.destination);
    osc.frequency.value = sounds[type].freq;
    gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + sounds[type].duration);
    osc.start(audioCtx.currentTime);
    osc.stop(audioCtx.currentTime + sounds[type].duration);
  } catch (e) {
    console.warn("Audio error:", e);
  }
}

document.getElementById("soundToggle").addEventListener("click", function() {
  soundEnabled = !soundEnabled;
  this.textContent = soundEnabled ? "ðŸ”Š" : "ðŸ”‡";
  this.classList.toggle("muted", !soundEnabled);
  if (soundEnabled) initAudio();
});

// ===== SOCKET EVENTS =====
// Determine if we should create or join based on mode parameter
if (URL_MODE === "bot" || URL_MODE === "create") {
  // Create a new room for bot games or explicit create mode
  console.log("ðŸŽ® Creating room:", currentRoom);
  socket.emit("create_room", {
    room: currentRoom,
    playerName: playerName,
    timeControl: URL_TIME,
    bot: URL_MODE === "bot",
    botDifficulty: params.get("difficulty") || "medium",
    gameMode: gameMode
  });
} else {
  // Join existing room for join/spectate/global modes
  console.log("ðŸšª Joining room:", currentRoom);
  socket.emit("join_room", {
    room: currentRoom,
    playerName: playerName,
    gameMode: gameMode
  });
}

socket.on("room_created", startGame);
socket.on("game_joined", startGame);

function startGame(data){
  console.log("ðŸŽ® startGame called with data:", data);
  
  // CRITICAL: Check data validity
  if (!data) {
    console.error("âŒ No data received in startGame!");
    alert("Error: No game data received from server!");
    return;
  }
  
  if (!data.state) {
    console.error("âŒ No state in data! Data keys:", Object.keys(data));
    alert("Error: Invalid game data received!");
    return;
  }
  
  if (!data.state.board) {
    console.error("âŒ No board in state! State keys:", Object.keys(data.state));
    alert("Error: No board data in game state!");
    return;
  }
  
  if (!Array.isArray(data.state.board)) {
    console.error("âŒ Board is not an array! Board type:", typeof data.state.board, "Value:", data.state.board);
    alert("Error: Invalid board format!");
    return;
  }
  
  console.log("âœ… Data validation passed");
  console.log("   Room:", data.room);
  console.log("   Color:", data.color);
  console.log("   Board:", data.state.board);
  
  document.getElementById("loadingMessage").style.display = "none";
  document.getElementById("game").style.display = "block";

  currentRoom = data.room;
  playerColor = data.color || data.state.color;  // Support both formats
  gameState = data.state;

  updatePlayerNames(gameState);

  const roomName = document.getElementById("roomName");
  if (roomName) {
    if (playerColor === "spectator") {
      roomName.textContent = "ðŸ›ï¸ Room: " + currentRoom + " (Spectating)";
    } else {
      roomName.textContent = "ðŸ›ï¸ Room: " + currentRoom;
    }
  }

  const defaultSeconds = URL_TIME || 300;
  whiteSeconds = gameState.whiteTimeFormatted ? timeStringToSeconds(gameState.whiteTimeFormatted) : defaultSeconds;
  blackSeconds = gameState.blackTimeFormatted ? timeStringToSeconds(gameState.blackTimeFormatted) : defaultSeconds;

  updateDisplayedTimers();

  const isWaiting = (gameState.isActive === false);
  updateWaitingOverlay(isWaiting);

  if (!isWaiting) {
      startLocalTimer();
  }

  console.log("ðŸ“ About to call renderBoard...");
  renderBoard(gameState);
  console.log("ðŸ“ Finished renderBoard");
  
  updateStatus(gameState);
  updateTurnIndicator(gameState);
  
  // Hide control buttons for spectators
  if (playerColor === "spectator") {
    const buttons = document.querySelectorAll('.btn-draw, .btn-resign, #rematchBtn');
    buttons.forEach(btn => btn.style.display = 'none');

    // Completely hide chat section for spectators
    const chatCard = document.querySelector('.card:has(#chatMessages)');
    if (chatCard) {
      chatCard.style.display = 'none';
    }
  }
  
  // Update spectator count if provided
  if (data.spectatorCount !== undefined) {
    updateSpectatorCount(data.spectatorCount);
  }
  
  console.log("âœ… startGame completed");
  console.log("   Player Color:", playerColor);
  console.log("   Turn:", gameState.turn);
  console.log("   Is Active:", gameState.isActive);
}

socket.on("game_start", d=>{
  gameState = d.state;
  updateWaitingOverlay(false);
  updatePlayerNames(gameState);
  startLocalTimer();
  renderBoard(gameState);
  updateStatus(gameState);
  updateTurnIndicator(gameState);
  playSound("notify");
});

function updateWaitingOverlay(show) {
    const wrapper = document.getElementById("boardWrapper");
    let overlay = document.getElementById("waitingOverlay");
    if (show) {
        if (!overlay) {
            overlay = document.createElement("div");
            overlay.id = "waitingOverlay";
            overlay.className = "waiting-overlay";
            overlay.innerHTML = `
                <div class="waiting-spinner"></div>
                <div style="font-size:1.1em; margin-bottom:4px; font-weight:900;">Waiting for opponent...</div>
                <div style="font-size:0.8em; color:#ddd;">Room: ${currentRoom}</div>
            `;
            wrapper.appendChild(overlay);
        }
    } else {
        if (overlay) overlay.remove();
    }
}

socket.on("player_disconnected", (data) => {
    if (data.color !== playerColor) {
        const overlay = document.getElementById("disconnectOverlay");
        const timerSpan = document.getElementById("disconnectTimer");
        let timeLeft = data.timeout || 15;
        
        if (overlay && timerSpan) {
            overlay.classList.add("active");
            timerSpan.textContent = timeLeft;
            
            if (disconnectInterval) clearInterval(disconnectInterval);
            disconnectInterval = setInterval(() => {
                timeLeft--;
                timerSpan.textContent = timeLeft;
                if (timeLeft <= 0) {
                    clearInterval(disconnectInterval);
                }
            }, 1000);
        }
    }
});

socket.on("player_reconnected", (data) => {
    const overlay = document.getElementById("disconnectOverlay");
    if (overlay) overlay.classList.remove("active");
    if (disconnectInterval) clearInterval(disconnectInterval);
});

socket.on("game_update", d => {
  if (isDragging) {
    pendingUpdate = d;
    return;
  }
  const now = Date.now();
  if (d.lastMove && lastMoveWasMine && (now - lastMoveTime < 260)) {
    setTimeout(() => processGameUpdate(d), 260 - (now - lastMoveTime));
    return;
  }
  processGameUpdate(d);
});

function processGameUpdate(d) {
  const prev = gameState;
  const isMyMoveConfirmation = d.lastMove && lastMoveWasMine;
  
  const performUpdate = () => {
    const boardChanged = JSON.stringify(prev.board) !== JSON.stringify(d.state.board);
    gameState = d.state;

    updatePlayerNames(gameState);

    pendingMoves.clear();
    const SERVER_SYNC_THRESHOLD = 2;
    if (gameState.whiteTimeFormatted !== undefined) {
      const srv = timeStringToSeconds(gameState.whiteTimeFormatted);
      if (srv > 0 && Math.abs(srv - whiteSeconds) > SERVER_SYNC_THRESHOLD) {
        whiteSeconds = srv;
      }
    }
    if (gameState.blackTimeFormatted !== undefined) {
      const srv = timeStringToSeconds(gameState.blackTimeFormatted);
      if (srv > 0 && Math.abs(srv - blackSeconds) > SERVER_SYNC_THRESHOLD) {
        blackSeconds = srv;
      }
    }

    updateDisplayedTimers();
    
    if (gameState.winner) {
        const overlay = document.getElementById("disconnectOverlay");
        if (overlay) overlay.classList.remove("active");
        if (disconnectInterval) clearInterval(disconnectInterval);
    }

    if (boardChanged || !isMyMoveConfirmation) {
      if (d.lastMove) addMoveToHistory(d.lastMove, d.moveNotation);
      renderBoard(gameState, d.lastMove);
    } else {
      if (d.lastMove) addMoveToHistory(d.lastMove, d.moveNotation);
    }
    updateStatus(gameState);
    updateTurnIndicator(gameState);
  };

  if (isMyMoveConfirmation) {
    setTimeout(performUpdate, 0);
  } else {
    if (d.lastMove && !lastMoveWasMine) {
      const wasCapture = prev && prev.board && prev.board[d.lastMove.to.row] && prev.board[d.lastMove.to.row][d.lastMove.to.col] !== ".";
      playSound(wasCapture ? "capture" : "move");
    }
    performUpdate();
  }
  lastMoveWasMine = false;
}

function updatePlayerNames(state) {
  const whiteNameEl = document.getElementById("whitePlayerName");
  const blackNameEl = document.getElementById("blackPlayerName");
  
  if (whiteNameEl && state.whiteName) {
    whiteNameEl.textContent = state.whiteName;
  }
  if (blackNameEl && state.blackName) {
    blackNameEl.textContent = state.blackName;
  }
}

function applyOptimisticMove(from, to, promotion) {
  const optimistic = JSON.parse(JSON.stringify(gameState));
  const piece = optimistic.board[from.row][from.col];
  optimistic.board[to.row][to.col] = promotion ? (piece.toUpperCase() === piece ? promotion.toUpperCase() : promotion.toLowerCase()) : piece;
  optimistic.board[from.row][from.col] = ".";
  optimistic.turn = optimistic.turn === "white" ? "black" : "white";
  return optimistic;
}

function animateMove(from, to, callback) {
  requestAnimationFrame(callback);
}

function updateSpectatorCount(count) {
  const spectatorCount = document.getElementById("spectatorCount");
  if (spectatorCount) {
    if (count > 0) {
      spectatorCount.textContent = `ðŸ‘ï¸ ${count} watching`;
      spectatorCount.style.display = 'inline';
    } else {
      spectatorCount.style.display = 'none';
    }
  }
}

socket.on("spectator_joined", (data) => {
  updateSpectatorCount(data.spectatorCount);
});

socket.on("spectator_left", (data) => {
  updateSpectatorCount(data.spectatorCount);
});

// ===== RENDER BOARD (IMPROVED WITH SAFETY CHECKS) =====
function renderBoard(state, lastMove=null){
  console.log("ðŸŽ¨ renderBoard called with state:", state);
  
  const board=document.getElementById("chessboard");
  if (!board) {
    console.error("âŒ Chessboard element not found!");
    return;
  }
  
  // CRITICAL: Check if state and state.board exist
  if (!state) {
    console.error("âŒ No state provided to renderBoard!");
    return;
  }
  
  if (!state.board) {
    console.error("âŒ No board in state! State keys:", Object.keys(state));
    return;
  }
  
  if (!Array.isArray(state.board) || state.board.length !== 8) {
    console.error("âŒ Invalid board format! Board:", state.board);
    return;
  }
  
  console.log("âœ… Rendering board. First row:", state.board[0]);
  
  board.innerHTML="";
  const flipped = (playerColor === "black");
  const rows = flipped ? [...Array(8).keys()].reverse() : [...Array(8).keys()];
  const cols = flipped ? [...Array(8).keys()].reverse() : [...Array(8).keys()];
  
  for (let r of rows){
    for (let c of cols){
      const sq=document.createElement("div");
      sq.className=`square ${(r+c)%2===0?"light":"dark"}`;
      sq.dataset.row=r;
      sq.dataset.col=c;

      const isBottom = (playerColor === "black") ? (r === 0) : (r === 7);
      const isLeft = (playerColor === "black") ? (c === 7) : (c === 0);

      if (isBottom) {
          const fileLabel = document.createElement("div");
          fileLabel.className = "square-coord file";
          fileLabel.textContent = String.fromCharCode(97 + c);
          sq.appendChild(fileLabel);
      }
      if (isLeft) {
          const rankLabel = document.createElement("div");
          rankLabel.className = "square-coord rank";
          rankLabel.textContent = (8 - r).toString();
          sq.appendChild(rankLabel);
      }

      if(lastMove){
        const fm=lastMove.from, to=lastMove.to;
        if((fm.row===r && fm.col===c)||(to.row===r && to.col===c)){
          sq.classList.add("last-move");
        }
      }
      if(selectedSquare && selectedSquare.row===r && selectedSquare.col===c){
        sq.classList.add("selected");
      }
      if(possibleMoves.some(m=>m.row===r && m.col===c)){
        sq.classList.add("possible-move");
      }
      
      // CRITICAL: Check if board[r] exists before accessing board[r][c]
      if (!state.board[r]) {
        console.error(`âŒ Board row ${r} is undefined!`);
        continue;
      }
      
      const piece = state.board[r][c];
      if(piece !== "."){
        const pDiv=document.createElement("div");
        pDiv.className="piece";
        const isWhitePiece = piece === piece.toUpperCase();
        const color = isWhitePiece ? "white" : "black";
        
        // Only allow dragging for the player's own pieces, not for spectators
        if(color === state.turn && color === playerColor && playerColor !== "spectator"){
          pDiv.draggable=true;
        }
        pDiv.dataset.row=r;
        pDiv.dataset.col=c;
        
        pDiv.addEventListener("dragstart", e=>{
          isDragging = true;
          selectedSquare = { row:r, col:c };
          
          const key = `${r},${c}`;
          possibleMoves = (state.moves && state.moves[key]) ? state.moves[key] : [];

          e.target.style.opacity = '0';
          
          const dragImg = e.target.cloneNode(true);
          dragImg.style.opacity = '1';
          dragImg.style.position = 'absolute';
          dragImg.style.top = '-1000px';
          dragImg.style.width = e.target.offsetWidth + 'px';
          dragImg.style.height = e.target.offsetHeight + 'px';
          document.body.appendChild(dragImg);
          const offsetX = e.target.offsetWidth / 2;
          const offsetY = e.target.offsetHeight / 2;
          e.dataTransfer.setDragImage(dragImg, offsetX, offsetY);
          setTimeout(() => dragImg.remove(), 0);

          document.querySelectorAll('.square').forEach(s => {
             s.classList.remove('selected', 'possible-move');
          });

          possibleMoves.forEach(m => {
             const targetSq = document.querySelector(`.square[data-row="${m.row}"][data-col="${m.col}"]`);
             if(targetSq) targetSq.classList.add('possible-move');
          });
          
          e.dataTransfer.setData("fromRow", r);
          e.dataTransfer.setData("fromCol", c);
        });

        pDiv.addEventListener("dragend", (e) => {
             e.target.style.opacity = '1';
             isDragging = false;
             selectedSquare = null;
             possibleMoves = [];
             if (pendingUpdate) {
               processGameUpdate(pendingUpdate);
               pendingUpdate = null;
             } else {
               renderBoard(gameState, lastMove);
             }
        });

        const img=document.createElement("img");
        const clr = isWhitePiece ? "w" : "b";
        const type = piece.toLowerCase();
        img.src=`https://images.chesscomfiles.com/chess-themes/pieces/neo/150/${clr}${type}.png`;
        img.onerror = function() {
          console.error(`âŒ Failed to load piece image: ${img.src}`);
        };
        pDiv.appendChild(img);
        sq.appendChild(pDiv);
      }

      // Click handlers
      sq.addEventListener("click", ()=> handleSquareClick(r,c,state));

      // Drag and Drop handlers
      sq.addEventListener("dragover", (e) => {
        e.preventDefault();
      });

      sq.addEventListener("drop", (e) => {
        e.preventDefault();
        const fr = parseInt(e.dataTransfer.getData("fromRow"));
        const fc = parseInt(e.dataTransfer.getData("fromCol"));
        const from = { row: fr, col: fc };
        const to = { row: r, col: c };

        if (!isNaN(fr) && !isNaN(fc)) {
          const movingPiece = state.board[fr][fc];
          const isPawn = movingPiece.toLowerCase() === "p";
          const isPromoRank = (playerColor === "white" && r === 0) ||
                              (playerColor === "black" && r === 7);
          if (isPawn && isPromoRank) {
            pendingPromotion = { from, to };
            showPromotionModal(playerColor);
          } else {
            makeMove(from,to,null,true);
          }
        }
      });
      board.appendChild(sq);
    }
  }
  
  console.log("âœ… Board rendered successfully");
}

function handleSquareClick(row, col, state){
  if(state.winner) return;
  
  // Prevent spectators from making moves
  if (playerColor === "spectator") {
    const messages = document.getElementById("messages");
    if (messages) messages.textContent = "ðŸ‘ï¸ You are spectating";
    return;
  }
  
  if (state.isActive === false) {
    const messages = document.getElementById("messages");
    if (messages) messages.textContent = "â³ Waiting for opponent...";
    return;
  }
  if(state.turn !== playerColor){
    const messages = document.getElementById("messages");
    if (messages) messages.textContent = "â³ Wait for your turn!";
    return;
  }
  const piece = state.board[row][col];
  const isWhite = piece !== "." && piece === piece.toUpperCase();
  const isMine = piece !== "." && (
    (playerColor==="white" && isWhite) ||
    (playerColor==="black" && !isWhite)
  );
  
  if(isMine){
    selectedSquare = { row,col };
    const key = `${row},${col}`;
    possibleMoves = (state.moves && state.moves[key]) ? state.moves[key] : [];
    
    renderBoard(state);
    
    const messages = document.getElementById("messages");
    if (messages) messages.textContent="";
    return;
  }

  if(!selectedSquare) return;
  const isValid = possibleMoves.some(m=>m.row===row && m.col===col);
  if(!isValid){
    const messages = document.getElementById("messages");
    if (messages) messages.textContent = "âŒ Invalid move!";
    return;
  }
  const movingPiece = state.board[selectedSquare.row][selectedSquare.col];
  const isPawn = movingPiece.toLowerCase()==="p";
  const isPromoRank = (playerColor==="white" && row===0) ||
                      (playerColor==="black" && row===7);
  if(isPawn && isPromoRank){
    pendingPromotion = { from:selectedSquare, to:{row,col} };
    showPromotionModal(playerColor);
  } else {
    makeMove(selectedSquare, {row,col}, null);
  }
}

function makeMove(from, to, promotion=null, isDrop=false){
  lastMoveWasMine = true;
  lastMoveTime = Date.now();
  const moveId = ++moveSequence;
  const previousState = JSON.parse(JSON.stringify(gameState));
  
  selectedSquare = null;
  possibleMoves = [];
  pendingPromotion = null;
  
  const performMove = () => {
    const optimisticState = applyOptimisticMove(from, to, promotion);
    if (optimisticState) {
      gameState = optimisticState;
      renderBoard(gameState, { from, to });
      updateTurnIndicator(gameState);
      const wasCapture = previousState.board[to.row][to.col] !== ".";
      playSound(wasCapture ? "capture" : "move");
      pendingMoves.set(moveId, {
        from, to, promotion, previousState, timestamp: Date.now()
      });
    }
  };

  if (!isDrop) {
    animateMove(from, to, performMove);
  } else {
    performMove();
  }

  socket.emit("move", { room: currentRoom, from, to, promotion, moveId });
  const messages = document.getElementById("messages");
  if (messages) messages.textContent = "";
}

function showPromotionModal(color){
  const modal=document.getElementById("promotionModal");
  const pcs=document.getElementById("promotionPieces");
  if (!modal || !pcs) return;
  pcs.innerHTML="";
  const opt=['q','r','b','n'];
  const pre = (color==="white") ? "w" : "b";
  opt.forEach(t=>{
    const img=document.createElement("img");
    img.src=`https://images.chesscomfiles.com/chess-themes/pieces/neo/150/${pre}${t}.png`;
    img.onclick = ()=>{
      makeMove(pendingPromotion.from, pendingPromotion.to, t);
      modal.classList.remove("active");
    };
    pcs.appendChild(img);
  });
  modal.classList.add("active");
}

function cancelPromotion(){
  pendingPromotion=null;
  const modal = document.getElementById("promotionModal");
  if (modal) modal.classList.remove("active");
}

function addMoveToHistory(lastMove,notation){
  moveHistory.push({ from:lastMove.from, to:lastMove.to, notation: notation });
  renderMoveHistory();
}

function renderMoveHistory(){
  const list=document.getElementById("moveList");
  if (!list) return;
  list.innerHTML="";
  for(let i=0;i<moveHistory.length;i+=2){
    const num=document.createElement("div");
    num.className="move-number";
    num.textContent=(i/2+1)+".";
    list.appendChild(num);
    const w=document.createElement("div");
    w.className="move-item white";
    w.textContent=moveHistory[i].notation;
    list.appendChild(w);
    if(i+1 < moveHistory.length){
      const b=document.createElement("div");
      b.className="move-item black";
      b.textContent=moveHistory[i+1].notation;
      list.appendChild(b);
    } else {
      list.appendChild(document.createElement("div"));
    }
  }
  const parent = list.parentElement;
  if (parent) parent.scrollTop = parent.scrollHeight;
}

function updateTurnIndicator(state){
  const ind=document.getElementById("turnIndicator");
  if (!ind) return;
  if(state.winner){
    ind.textContent="ðŸ Game Over";
    ind.style.background="linear-gradient(135deg, #11998e 0%, #38ef7d 100%)";
    ind.style.color="#fff";
    return;
  }
  ind.textContent = (state.turn==="white") ? "â™” White to move" : "â™š Black to move";
  ind.style.background = "";
  ind.style.color = "";
}

function updateStatus(state){
  const s=document.getElementById("status");
  const rematchBtn = document.getElementById("rematchBtn");
  const drawBtn = document.querySelector(".btn-draw");
  const resignBtn = document.querySelector(".btn-resign");

  if (!s) return;

  if(state.winner){
    if (rematchBtn) {
        rematchBtn.classList.add("active");
        rematchBtn.disabled = false;
    }

    // Disable Draw and Resign buttons when game is over
    if (drawBtn) {
        drawBtn.disabled = true;
        drawBtn.style.opacity = "0.5";
        drawBtn.style.cursor = "not-allowed";
    }
    if (resignBtn) {
        resignBtn.disabled = true;
        resignBtn.style.opacity = "0.5";
        resignBtn.style.cursor = "not-allowed";
    }

    if(state.winner==="draw"){
      s.textContent="ðŸ¤ Game Draw!";
      s.style.background="linear-gradient(135deg, #f7971e 0%, #ffd200 100%)";
      s.style.color="#fff";
    } else {
      const w = state.winner==="white" ? "â™” WHITE" : "â™š BLACK";
      const r =
        state.reason==="checkmate" ? "by Checkmate" :
        state.reason==="resign" ? "by Resignation" :
        state.reason==="timeout" ? "by Timeout" :
        state.reason==="abandonment" ? "by Abandonment" : "";
      s.textContent=`ðŸ‘‘ ${w} Wins ${r}!`;
      s.style.background="linear-gradient(135deg, #11998e 0%, #38ef7d 100%)";
      s.style.color="#fff";
    }
    return;
  }

  if (rematchBtn) {
      rematchBtn.classList.remove("active");
  }

  // Re-enable Draw and Resign buttons when game is active
  if (drawBtn) {
      drawBtn.disabled = false;
      drawBtn.style.opacity = "1";
      drawBtn.style.cursor = "pointer";
  }
  if (resignBtn) {
      resignBtn.disabled = false;
      resignBtn.style.opacity = "1";
      resignBtn.style.cursor = "pointer";
  }

  if(state.check){
    const t = state.turn==="white"?"â™” WHITE":"â™š BLACK";
    s.textContent=`âš ï¸ CHECK! ${t}'s turn`;
    s.style.background="linear-gradient(135deg, #eb3349 0%, #f45c43 100%)";
    s.style.color="#fff";
    return;
  }
  s.textContent="\u00A0";
  s.style.background="rgba(102, 126, 234, 0.1)";
  s.style.color="#333";
}

function goHome(){
  if(confirm("Return to home? Current game will end.")){
    socket.emit("leave_room",{room:currentRoom});
    window.location.href = "/";
  }
}

function offerDraw(){
  socket.emit("offer_draw",{room:currentRoom,color:playerColor});
  const messages = document.getElementById("messages");
  if (messages) messages.textContent="ðŸ¤ Draw offer sent...";
}

socket.on("draw_offered", data=>{
  // Don't show draw modal to spectators
  if (playerColor === "spectator") return;

  const drawMessage = document.getElementById("drawMessage");
  const drawModal = document.getElementById("drawModal");
  if (drawMessage && drawModal) {
    drawMessage.textContent = `${data.fromColor.toUpperCase()} offers a draw. Accept?`;
    drawModal.classList.add("active");
  }
});

socket.on("draw_declined", ()=>{
  const messages = document.getElementById("messages");
  if (messages) messages.textContent="âŒ Opponent declined your draw.";
});

function respondToDraw(acc){
  const drawModal = document.getElementById("drawModal");
  if (drawModal) drawModal.classList.remove("active");
  socket.emit("respond_draw",{room:currentRoom,accept:acc});
}

function resignGame(){
  if(confirm("Are you sure you want to resign?")){
    socket.emit("resign",{room:currentRoom,color:playerColor});
  }
}

// ===== CHAT =====
const chatInput = document.getElementById("chatInput");
const chatMessages = document.getElementById("chatMessages");
let typingTimeout;

chatInput.addEventListener("input", () => {
  socket.emit("typing", { room: currentRoom, sender: playerColor });
  clearTimeout(typingTimeout);
  typingTimeout = setTimeout(() => {
    socket.emit("stop_typing", { room: currentRoom, sender: playerColor });
  }, 1000);
});

chatInput.addEventListener("keypress", (e) => {
  if (e.key === "Enter") {
    sendMessage();
  }
});

function sendMessage() {
  const msg = chatInput.value.trim();
  if (!msg) return;
  socket.emit("send_message", { room: currentRoom, sender: playerColor, message: msg });
  chatInput.value = "";
  socket.emit("stop_typing", { room: currentRoom, sender: playerColor });
}

socket.on("chat_message", (data) => {
  const msgDiv = document.createElement("div");
  msgDiv.className = `chat-message ${data.sender}`;
  const senderName = data.sender === "white" ? (gameState?.whiteName || "White") : (gameState?.blackName || "Black");
  msgDiv.innerHTML = `<strong>${senderName}:</strong> ${escapeHtml(data.message)}`;
  chatMessages.appendChild(msgDiv);
  chatMessages.scrollTop = chatMessages.scrollHeight;
});

socket.on("user_typing", (data) => {
  const typingIndicator = document.getElementById("typingIndicator");
  if (typingIndicator && data.sender !== playerColor) {
    typingIndicator.classList.add("active");
  }
});

socket.on("user_stop_typing", (data) => {
  const typingIndicator = document.getElementById("typingIndicator");
  if (typingIndicator) {
    typingIndicator.classList.remove("active");
  }
});

function escapeHtml(text) {
  const div = document.createElement('div');
  div.textContent = text;
  return div.innerHTML;
}

// Simple emoji picker
const emojiToggle = document.getElementById("emojiToggle");
const emojis = ["ðŸ˜Š", "ðŸ˜‚", "ðŸ‘", "â¤ï¸", "ðŸŽ‰", "ðŸ˜Ž", "ðŸ¤”", "ðŸ˜­"];
let emojiIndex = 0;

emojiToggle.addEventListener("click", () => {
  chatInput.value += emojis[emojiIndex];
  emojiIndex = (emojiIndex + 1) % emojis.length;
  chatInput.focus();
});
</script>
</body>
</html>
