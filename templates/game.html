<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Chess Master ‚Äî Premium Edition</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
  <style>
    * { margin:0; padding:0; box-sizing:border-box; }

    body {
      font-family:'Inter','Segoe UI','Helvetica Neue',sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      height:100vh;
      display:flex;
      justify-content:center;
      align-items:center;
      padding:8px;
      position:relative;
      overflow:hidden;
      user-select: none;
      -webkit-user-select: none;
    }

    /* GLASSMORPHISM CONTAINER */
    .container {
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(20px) saturate(180%);
      -webkit-backdrop-filter: blur(20px) saturate(180%);
      border-radius: 12px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
      padding: 6px;
      width: 100%;
      max-width: 1350px;
      max-height: calc(100vh - 16px);
      overflow-y: auto;
      position: relative;
      animation: containerFadeIn 0.6s ease;
    }

    @keyframes containerFadeIn {
      from { opacity: 0; transform: translateY(20px); }
      to { opacity: 1; transform: translateY(0); }
    }

    /* HEADER */
    .header {
      text-align: center;
      margin-bottom: 6px;
      position: relative;
    }

    h1 {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 50%, #f093fb 100%);
      background-size: 200% auto;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      font-size: 18px;
      font-weight: 900;
      margin-bottom: 2px;
      letter-spacing: -1px;
      animation: titleShine 3s linear infinite;
    }

    @keyframes titleShine {
      to { background-position: 200% center; }
    }

    .subtitle {
      color: #666;
      font-size: 9px;
      font-weight: 600;
      letter-spacing: 0.5px;
    }

    .sound-toggle {
      position: absolute;
      top: 0;
      right: 0;
      width: 28px;
      height: 28px;
      background: rgba(102, 126, 234, 0.1);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      cursor: pointer;
      transition: all 0.3s ease;
      border: 2px solid rgba(102, 126, 234, 0.2);
    }
    .sound-toggle:hover {
      transform: scale(1.1);
      background: rgba(102, 126, 234, 0.2);
    }
    .sound-toggle.muted {
      opacity: 0.5;
      background: rgba(220, 38, 38, 0.1);
    }

    /* LOADING */
    #loadingMessage {
      text-align: center;
      padding: 60px 20px;
      font-weight: bold;
      color: #333;
      font-size: clamp(14px, 2.5vw, 18px);
    }

    /* GAME INFO BAR */
    .game-info-bar {
      background: linear-gradient(135deg, rgba(102, 126, 234, 0.1) 0%, rgba(118, 75, 162, 0.1) 100%);
      padding: 4px 8px;
      border-radius: 6px;
      margin-bottom: 6px;
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 8px;
      border: 2px solid rgba(102, 126, 234, 0.2);
    }

    .game-info-bar h3 {
      font-size: 11px;
      color: #333;
      font-weight: 800;
    }

    /* MAIN LAYOUT - Optimized for 1366x768 */
    .game-layout {
      display: grid;
      grid-template-columns: 1fr 280px;
      gap: 10px;
      align-items: start;
    }

    /* BOARD SECTION */
    .board-section {
      display: flex;
      flex-direction: column;
      gap: 5px;
      max-height: 100%;
    }

    /* PLAYER INFO CARDS */
    .player-card {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 4px 8px;
      border-radius: 6px;
      background: rgba(255, 255, 255, 0.8);
      border: 2px solid #e0e0e0;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      min-height: 32px;
    }

    .player-card.black {
      background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
      border-color: #2c3e50;
    }

    .player-info {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .player-avatar {
      width: 22px;
      height: 22px;
      border-radius: 50%;
      background: rgba(102, 126, 234, 0.2);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      border: 2px solid rgba(102, 126, 234, 0.3);
    }

    .player-card.black .player-avatar {
      background: rgba(255, 255, 255, 0.2);
      border-color: rgba(255, 255, 255, 0.3);
    }

    .player-name-text {
      font-size: 10px;
      font-weight: 700;
      color: #333;
      max-width: 100px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .player-card.black .player-name-text {
      color: #fff;
    }

    .timer {
      padding: 3px 8px;
      border-radius: 5px;
      font-size: 11px;
      font-weight: 800;
      background: rgba(102, 126, 234, 0.1);
      color: #333;
      border: 2px solid rgba(102, 126, 234, 0.2);
      min-width: 52px;
      text-align: center;
      transition: all 0.3s ease;
    }

    .player-card.black .timer {
      background: rgba(255, 255, 255, 0.15);
      color: #fff;
      border-color: rgba(255, 255, 255, 0.3);
    }

    .timer.active {
      animation: timerPulse 1.5s ease-in-out infinite;
      box-shadow: 0 0 20px rgba(102, 126, 234, 0.5);
      background: rgba(102, 126, 234, 0.2);
    }

    .player-card.black .timer.active {
      box-shadow: 0 0 20px rgba(255, 255, 255, 0.4);
      background: rgba(255, 255, 255, 0.25);
    }

    @keyframes timerPulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.05); }
    }

    /* TURN INDICATOR */
    .turn-indicator {
      text-align: center;
      padding: 4px;
      border-radius: 6px;
      font-size: 10px;
      font-weight: 800;
      background: linear-gradient(135deg, rgba(102, 126, 234, 0.1) 0%, rgba(118, 75, 162, 0.1) 100%);
      color: #333;
      border: 2px solid rgba(102, 126, 234, 0.2);
      height: 26px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    /* CHESSBOARD - Optimized for 1366x768 */
    .board-wrapper {
      position: relative;
      width: 100%;
      max-width: 450px;
      max-height: 450px;
      margin: 0 auto;
    }

    .chessboard {
      display: grid;
      grid-template-columns: repeat(8, 1fr);
      width: 100%;
      max-height: 100%;
      aspect-ratio: 1 / 1;
      border: 3px solid #2c3e50;
      border-radius: 10px;
      overflow: hidden;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
      background: #fff;
    }

    .waiting-overlay, .disconnect-overlay {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      backdrop-filter: blur(5px);
      z-index: 100;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      border-radius: 10px;
      color: white;
      font-weight: bold;
      animation: fadeIn 0.3s;
      font-size: clamp(11px, 2.5vw, 14px);
      padding: 15px;
      text-align: center;
    }

    .waiting-overlay {
      background: rgba(0, 0, 0, 0.7);
    }

    .disconnect-overlay {
      background: rgba(220, 38, 38, 0.85);
      display: none;
    }
    .disconnect-overlay.active {
      display: flex;
    }
    
    .waiting-spinner {
      border: 3px solid rgba(255, 255, 255, 0.3);
      border-top: 3px solid #fff;
      border-radius: 50%;
      width: 35px;
      height: 35px;
      animation: spin 1s linear infinite;
      margin-bottom: 12px;
    }
    @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }

    .square-coord {
      position: absolute;
      font-size: clamp(7px, 1.2vw, 9px);
      font-weight: 800;
      pointer-events: none;
      user-select: none;
      opacity: 0.7;
      z-index: 5;
    }
    .square-coord.file {
      bottom: 2px;
      right: 2px;
    }
    .square-coord.rank {
      top: 2px;
      left: 2px;
    }
    .square.light .square-coord { color: #b58863; }
    .square.dark .square-coord { color: #f0d9b5; }

    .square {
      aspect-ratio: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
      position: relative;
    }
    .square.light {
      background: linear-gradient(135deg, #f5e6d3 0%, #f0d9b5 100%);
    }
    .square.dark {
      background: linear-gradient(135deg, #c9a882 0%, #b58863 100%);
    }
    .square:hover {
      filter: brightness(1.1);
    }
    .square.selected {
      box-shadow: inset 0 0 0 3px rgba(102, 126, 234, 0.8);
      z-index: 10;
    }
    .square.last-move {
      background-blend-mode: multiply;
      position: relative;
    }
    .square.last-move.light {
      background: linear-gradient(135deg, rgba(240, 186, 90, 0.5) 0%, rgba(240, 186, 90, 0.4) 100%), 
                  linear-gradient(135deg, #f5e6d3 0%, #f0d9b5 100%);
    }
    .square.last-move.dark {
      background: linear-gradient(135deg, rgba(170, 139, 87, 0.5) 0%, rgba(170, 139, 87, 0.4) 100%), 
                  linear-gradient(135deg, #c9a882 0%, #b58863 100%);
    }
    .square.possible-move::after {
      content:"";
      width:35%;
      height:35%;
      background: rgba(102, 126, 234, 0.5);
      border-radius:50%;
      pointer-events:none;
      position: absolute;
      animation: moveHintPulse 1.5s ease-in-out infinite;
    }
    .square.possible-move.has-piece::after {
      width: 90%;
      height: 90%;
      background: transparent;
      border: 3px solid rgba(220, 38, 38, 0.6);
      border-radius: 50%;
    }
    @keyframes moveHintPulse {
      0%, 100% { transform: scale(1); opacity: 0.5; }
      50% { transform: scale(1.2); opacity: 0.8; }
    }

    .piece {
      width:85%;
      height:85%;
      display:flex;
      align-items:center;
      justify-content:center;
      transition: transform 0.15s cubic-bezier(0.4, 0, 0.2, 1);
      position: relative;
      z-index: 10;
    }
    .piece img {
      width:100%;
      height:100%;
      object-fit:contain;
      pointer-events:none;
      filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3));
    }
    .piece[draggable="true"]:hover {
      transform: scale(1.08);
      cursor: grab;
    }
    .piece[draggable="true"]:active {
      cursor: grabbing;
    }

    /* SIDEBAR */
    .sidebar {
      display: flex;
      flex-direction: column;
      gap: 6px;
      max-height: 100%;
    }

    .card {
      background: rgba(255, 255, 255, 0.9);
      border-radius: 8px;
      padding: 6px;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
      border: 2px solid rgba(102, 126, 234, 0.2);
    }

    .card-header {
      font-size: 10px;
      font-weight: 800;
      color: #667eea;
      margin-bottom: 6px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      display: flex;
      align-items: center;
      gap: 5px;
    }

    #status {
      padding: 6px;
      border-radius: 6px;
      text-align: center;
      font-weight: 700;
      font-size: 10px;
      background: rgba(102, 126, 234, 0.1);
      color: #333;
      border: 2px solid rgba(102, 126, 234, 0.2);
      min-height: 26px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #messages {
      padding: 5px;
      border-radius: 5px;
      text-align: center;
      font-size: 9px;
      font-weight: 700;
      color: #333;
      min-height: 22px;
      background: rgba(255, 255, 255, 0.5);
    }

    /* MOVE HISTORY */
    .moves-container {
      max-height: 140px;
      overflow-y: auto;
      border-radius: 6px;
      background: rgba(0, 0, 0, 0.03);
      padding: 4px;
    }

    #moveList {
      display: grid;
      grid-template-columns: 22px 1fr 1fr;
      gap: 3px;
      font-size: 9px;
      font-weight: 600;
    }

    .move-number {
      color: #667eea;
      font-weight: 800;
      text-align: center;
      padding: 3px 0;
    }

    .move-item {
      padding: 3px 6px;
      border-radius: 4px;
      background: rgba(255, 255, 255, 0.8);
      border: 1px solid rgba(0, 0, 0, 0.1);
      transition: all 0.2s ease;
      cursor: pointer;
    }

    .move-item:hover {
      background: rgba(102, 126, 234, 0.1);
      transform: translateX(2px);
    }

    .move-item.white {
      border-left: 3px solid #f0d9b5;
    }

    .move-item.black {
      border-left: 3px solid #b58863;
    }

    /* CONTROLS */
    .controls {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 4px;
    }

    .btn {
      padding: 6px 8px;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 9px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.3px;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
      position: relative;
      overflow: hidden;
    }

    .btn::before {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 0;
      height: 0;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.5);
      transform: translate(-50%, -50%);
      transition: width 0.6s, height 0.6s;
    }

    .btn:hover::before {
      width: 300px;
      height: 300px;
    }

    .btn span {
      position: relative;
      z-index: 1;
    }

    .btn-home {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
    }

    .btn-home:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
    }

    .btn-draw {
      background: linear-gradient(135deg, #f7971e 0%, #ffd200 100%);
      color: white;
    }

    .btn-draw:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(247, 151, 30, 0.4);
    }

    .btn-resign {
      background: linear-gradient(135deg, #eb3349 0%, #f45c43 100%);
      color: white;
      grid-column: span 2;
    }

    .btn-resign:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(235, 51, 73, 0.4);
    }

    .btn-rematch {
      background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
      color: white;
      grid-column: span 2;
      opacity: 0.5;
      cursor: not-allowed;
      transition: all 0.3s ease;
    }

    .btn-rematch.active {
      opacity: 1;
      cursor: pointer;
    }

    .btn-rematch.active:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(17, 153, 142, 0.4);
    }

    /* CHAT */
    .chat-container {
      display: flex;
      flex-direction: column;
      max-height: 130px;
    }

    #chatMessages {
      flex: 1;
      overflow-y: auto;
      padding: 4px;
      background: rgba(0, 0, 0, 0.03);
      border-radius: 6px;
      margin-bottom: 4px;
      min-height: 70px;
      max-height: 90px;
      font-size: 9px;
    }

    .chat-message {
      padding: 3px 6px;
      margin-bottom: 3px;
      border-radius: 4px;
      word-wrap: break-word;
      animation: messageFadeIn 0.3s ease;
    }

    @keyframes messageFadeIn {
      from { opacity: 0; transform: translateY(-5px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .chat-message.white {
      background: rgba(240, 217, 181, 0.3);
      border-left: 3px solid #f0d9b5;
    }

    .chat-message.black {
      background: rgba(181, 136, 99, 0.3);
      border-left: 3px solid #b58863;
    }

    .chat-message strong {
      color: #667eea;
      font-weight: 800;
    }

    .chat-input-area {
      display: flex;
      gap: 4px;
    }

    #chatInput {
      flex: 1;
      padding: 5px 8px;
      border: 2px solid rgba(102, 126, 234, 0.3);
      border-radius: 6px;
      font-size: 9px;
      outline: none;
      transition: border-color 0.3s ease;
      font-family: inherit;
    }

    #chatInput:focus {
      border-color: rgba(102, 126, 234, 0.6);
    }

    .btn-send {
      padding: 5px 10px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 9px;
      font-weight: 700;
      transition: all 0.3s ease;
    }

    .btn-send:hover {
      transform: scale(1.05);
      box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
    }

    /* TYPING INDICATOR */
    .typing-indicator {
      padding: 3px 8px;
      font-size: 8px;
      color: #999;
      font-style: italic;
      display: none;
    }

    .typing-indicator.active {
      display: block;
    }

    /* MODALS */
    .modal {
      display: none;
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0, 0, 0, 0.7);
      backdrop-filter: blur(5px);
      z-index: 1000;
      align-items: center;
      justify-content: center;
      animation: fadeIn 0.3s ease;
    }

    .modal.active {
      display: flex;
    }

    .modal-content {
      background: white;
      padding: 20px;
      border-radius: 12px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
      max-width: 400px;
      width: 90%;
      animation: modalSlideIn 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    @keyframes modalSlideIn {
      from { transform: translateY(-50px); opacity: 0; }
      to { transform: translateY(0); opacity: 1; }
    }

    .modal-content h3 {
      font-size: 16px;
      margin-bottom: 15px;
      color: #667eea;
      font-weight: 800;
    }

    .modal-content p {
      font-size: 13px;
      margin-bottom: 15px;
      color: #666;
    }

    #promotionPieces {
      display: flex;
      justify-content: center;
      gap: 12px;
      margin-bottom: 15px;
    }

    #promotionPieces img {
      width: 60px;
      height: 60px;
      cursor: pointer;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      border-radius: 8px;
      padding: 5px;
      border: 2px solid transparent;
    }

    #promotionPieces img:hover {
      transform: scale(1.15);
      background: rgba(102, 126, 234, 0.1);
      border-color: rgba(102, 126, 234, 0.3);
    }

    .modal-buttons {
      display: flex;
      gap: 10px;
      justify-content: flex-end;
    }

    .modal-btn {
      padding: 8px 16px;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 12px;
      font-weight: 700;
      transition: all 0.3s ease;
    }

    .modal-btn.accept {
      background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
      color: white;
    }

    .modal-btn.accept:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(17, 153, 142, 0.4);
    }

    .modal-btn.decline {
      background: linear-gradient(135deg, #eb3349 0%, #f45c43 100%);
      color: white;
    }

    .modal-btn.decline:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(235, 51, 73, 0.4);
    }

    /* EMOJI PICKER */
    .emoji-toggle {
      background: none;
      border: none;
      font-size: 14px;
      cursor: pointer;
      padding: 5px;
      transition: transform 0.2s ease;
    }

    .emoji-toggle:hover {
      transform: scale(1.2);
    }

    /* MOBILE RESPONSIVE */
    @media (max-width: 1100px) {
      .game-layout {
        grid-template-columns: 1fr;
      }

      .sidebar {
        grid-template-columns: repeat(2, 1fr);
        gap: 8px;
      }

      .card {
        height: auto;
      }

      .controls {
        grid-column: span 2;
      }
    }

    @media (max-width: 768px) {
      .container {
        padding: 4px;
      }

      h1 {
        font-size: 16px;
      }

      .subtitle {
        font-size: 8px;
      }

      .board-wrapper {
        max-width: 100%;
      }

      .sidebar {
        display: grid;
        grid-template-columns: 1fr;
      }

      #chatMessages {
        max-height: 100px;
      }
    }

    @media (max-width: 480px) {
      .game-layout {
        gap: 6px;
      }

      .player-card {
        padding: 3px 6px;
        min-height: 28px;
      }

      .timer {
        padding: 2px 6px;
        font-size: 10px;
        min-width: 45px;
      }

      .card {
        padding: 5px;
      }

      .card-header {
        font-size: 9px;
      }

      #status, #turnIndicator {
        font-size: 9px;
        min-height: 24px;
      }
    }

    /* SPECTATOR BADGE */
    .spectator-badge {
      display: inline-block;
      padding: 2px 6px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border-radius: 4px;
      font-size: 8px;
      font-weight: 800;
      margin-left: 5px;
      animation: badgePulse 2s ease-in-out infinite;
    }

    @keyframes badgePulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }

    .spectator-count {
      font-size: 9px;
      color: #667eea;
      font-weight: 700;
      margin-left: 5px;
    }

    /* MATCHMAKING INDICATOR */
    .matchmaking-indicator {
      display: none;
      text-align: center;
      padding: 20px;
      font-size: 14px;
      font-weight: 700;
      color: #667eea;
    }

    .matchmaking-indicator.active {
      display: block;
    }

    .matchmaking-spinner {
      border: 3px solid rgba(102, 126, 234, 0.3);
      border-top: 3px solid #667eea;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      animation: spin 1s linear infinite;
      margin: 10px auto;
    }
  </style>
</head>
<body>
<div class="container">
  <div class="header">
    <h1>‚ôüÔ∏è Chess Master ‚ôõ</h1>
    <div class="subtitle">Premium Edition ‚Äî Real-time Multiplayer</div>
    <div class="sound-toggle" id="soundToggle" title="Toggle Sound">üîä</div>
  </div>

  <div id="loadingMessage">
    <div style="font-size: 40px; margin-bottom: 20px;">‚ôüÔ∏è</div>
    <div>Connecting to game...</div>
  </div>

  <div id="game" style="display:none;">
    <div class="game-info-bar">
      <h3 id="roomName">üèõÔ∏è Room: </h3>
    </div>

    <div class="game-layout">
      <div class="board-section">
        <!-- TOP PLAYER (Black) -->
        <div class="player-card black">
          <div class="player-info">
            <div class="player-avatar">‚ôö</div>
            <div class="player-name-text" id="blackPlayerName">Black</div>
          </div>
          <div class="timer" id="blackTimer">5:00</div>
        </div>

        <!-- CHESSBOARD -->
        <div class="board-wrapper" id="boardWrapper">
          <div class="chessboard" id="chessboard"></div>
          <div class="disconnect-overlay" id="disconnectOverlay">
            <div style="font-size:1.2em; margin-bottom:8px; font-weight:900;">‚ö†Ô∏è Opponent Disconnected</div>
            <div style="font-size:0.9em;">Reconnecting in <span id="disconnectTimer">15</span>s...</div>
            <div style="font-size:0.8em; margin-top:8px; opacity:0.9;">You will win if they don't return</div>
          </div>
        </div>

        <!-- TURN INDICATOR -->
        <div class="turn-indicator" id="turnIndicator">‚ôî White to move</div>

        <!-- BOTTOM PLAYER (White) -->
        <div class="player-card">
          <div class="player-info">
            <div class="player-avatar">‚ôî</div>
            <div class="player-name-text" id="whitePlayerName">White</div>
          </div>
          <div class="timer" id="whiteTimer">5:00</div>
        </div>
      </div>

      <!-- SIDEBAR -->
      <div class="sidebar">
        <!-- STATUS CARD -->
        <div class="card">
          <div class="card-header">üìä Game Status</div>
          <div id="status">&nbsp;</div>
          <div id="messages"></div>
        </div>

        <!-- MOVE HISTORY -->
        <div class="card">
          <div class="card-header">
            üìú Move History
            <span class="spectator-count" id="spectatorCount" style="display:none;"></span>
          </div>
          <div class="moves-container">
            <div id="moveList"></div>
          </div>
        </div>

        <!-- CONTROLS -->
        <div class="card">
          <div class="card-header">üéÆ Controls</div>
          <div class="controls">
            <button class="btn btn-home" onclick="goHome()"><span>üè† Home</span></button>
            <button class="btn btn-draw" onclick="offerDraw()"><span>ü§ù Draw</span></button>
            <button class="btn btn-resign" onclick="resignGame()"><span>üè≥Ô∏è Resign</span></button>
            <button class="btn btn-rematch" id="rematchBtn" onclick="window.location.href='/'"><span>üîÑ Rematch</span></button>
          </div>
        </div>

        <!-- LIVE CHAT -->
        <div class="card">
          <div class="card-header">üí¨ Live Chat</div>
          <div class="chat-container">
            <div id="chatMessages"></div>
            <div class="typing-indicator" id="typingIndicator">Opponent is typing...</div>
            <div class="chat-input-area">
              <button class="emoji-toggle" id="emojiToggle">üòä</button>
              <input type="text" id="chatInput" placeholder="Type a message..." maxlength="100" />
              <button class="btn-send" onclick="sendMessage()">Send</button>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- PROMOTION MODAL -->
<div class="modal" id="promotionModal">
  <div class="modal-content">
    <h3>‚ôï Promote Pawn</h3>
    <p>Choose a piece for promotion:</p>
    <div id="promotionPieces"></div>
    <div class="modal-buttons">
      <button class="modal-btn decline" onclick="cancelPromotion()">Cancel</button>
    </div>
  </div>
</div>

<!-- DRAW OFFER MODAL -->
<div class="modal" id="drawModal">
  <div class="modal-content">
    <h3>ü§ù Draw Offer</h3>
    <p id="drawMessage">Opponent offers a draw. Accept?</p>
    <div class="modal-buttons">
      <button class="modal-btn decline" onclick="respondToDraw(false)">Decline</button>
      <button class="modal-btn accept" onclick="respondToDraw(true)">Accept</button>
    </div>
  </div>
</div>

<script>
// ===== PARSE URL PARAMS =====
const params = new URLSearchParams(window.location.search);
const URL_ROOM = params.get("room");
const URL_NAME = params.get("name") || "Player";
const URL_TIME = parseInt(params.get("time")) || 300;
const URL_MODE = params.get("mode") || "friend";

if (!URL_ROOM) {
  alert("No room specified!");
  window.location.href = "/";
}

// ===== SOCKET CONNECTION =====
const socket = io();

// Enhanced socket connection logging
socket.on("connect", () => {
  console.log("‚úÖ Socket connected! ID:", socket.id);
});

socket.on("connect_error", (error) => {
  console.error("‚ùå Socket connection error:", error);
  alert("Connection error! Check your internet connection.");
});

socket.on("disconnect", (reason) => {
  console.warn("‚ö†Ô∏è Socket disconnected:", reason);
});

socket.on("error", (error) => {
  console.error("‚ùå Socket error:", error);
  if (error && error.message) {
    alert("Socket error: " + error.message);
  }
});

// ===== GAME STATE =====
let currentRoom = URL_ROOM;
let playerColor = null;
let playerName = URL_NAME;
let gameState = null;
let selectedSquare = null;
let possibleMoves = [];
let pendingPromotion = null;
let moveHistory = [];
let soundEnabled = true;
let lastMoveWasMine = false;
let lastMoveTime = 0;
let whiteSeconds = 0;
let blackSeconds = 0;
let timerInterval = null;
let pendingMoves = new Map();
let moveSequence = 0;
let disconnectInterval = null;
let isDragging = false;
let pendingUpdate = null;
let gameMode = URL_MODE || "friend";

function timeStringToSeconds(str) {
  if (!str || typeof str !== "string" || !str.includes(":")) return 0;
  const [m, s] = str.split(":").map(Number);
  return m * 60 + s;
}

function formatSeconds(sec) {
  sec = Math.max(0, Math.floor(sec));
  const m = Math.floor(sec / 60);
  const s = sec % 60;
  return `${m}:${s.toString().padStart(2, "0")}`;
}

function updateDisplayedTimers() {
  const whiteTimer = document.getElementById("whiteTimer");
  const blackTimer = document.getElementById("blackTimer");
  
  if (whiteTimer) whiteTimer.textContent = formatSeconds(whiteSeconds);
  if (blackTimer) blackTimer.textContent = formatSeconds(blackSeconds);
  
  if (gameState && !gameState.winner) {
    const activeColor = gameState.turn;
    if (whiteTimer) whiteTimer.classList.toggle("active", activeColor === "white");
    if (blackTimer) blackTimer.classList.toggle("active", activeColor === "black");
  } else {
    if (whiteTimer) whiteTimer.classList.remove("active");
    if (blackTimer) blackTimer.classList.remove("active");
  }
}

function startLocalTimer() {
  if (timerInterval) clearInterval(timerInterval);

  timerInterval = setInterval(() => {
    if (!gameState || gameState.winner || (gameState.isActive === false)) {
      clearInterval(timerInterval);
      return;
    }
    if (gameState.turn === "white" && whiteSeconds > 0) {
      whiteSeconds = Math.max(0, whiteSeconds - 1);
    } else if (gameState.turn === "black" && blackSeconds > 0) {
      blackSeconds = Math.max(0, blackSeconds - 1);
    }
    updateDisplayedTimers();
    if (whiteSeconds === 0 || blackSeconds === 0) {
      clearInterval(timerInterval);
    }
  }, 1000);
}

const sounds = {
  move: { freq: 400, duration: 0.1 },
  capture: { freq: 300, duration: 0.15 },
  check: { freq: 600, duration: 0.2 },
  win: { freq: 800, duration: 0.3 },
  notify: { freq: 500, duration: 0.1 }
};

let audioCtx = null;

function initAudio() {
  if (typeof window.AudioContext === 'undefined' && typeof window.webkitAudioContext === 'undefined') return;
  if (!audioCtx) {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  }
  if (audioCtx.state === 'suspended') {
    audioCtx.resume();
  }
}

function playSound(type) {
  if (!soundEnabled) return;
  try {
    initAudio();
    if (!audioCtx) return;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.connect(gain); 
    gain.connect(audioCtx.destination);
    osc.frequency.value = sounds[type].freq;
    gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + sounds[type].duration);
    osc.start(audioCtx.currentTime);
    osc.stop(audioCtx.currentTime + sounds[type].duration);
  } catch (e) {
    console.warn("Audio error:", e);
  }
}

document.getElementById("soundToggle").addEventListener("click", function() {
  soundEnabled = !soundEnabled;
  this.textContent = soundEnabled ? "üîä" : "üîá";
  this.classList.toggle("muted", !soundEnabled);
  if (soundEnabled) initAudio();
});

// ===== SOCKET EVENTS =====
// Determine if we should create or join based on mode parameter
if (URL_MODE === "bot" || URL_MODE === "create") {
  // Create a new room for bot games or explicit create mode
  console.log("üéÆ Creating room:", currentRoom);
  socket.emit("create_room", {
    room: currentRoom,
    playerName: playerName,
    timeControl: URL_TIME,
    bot: URL_MODE === "bot",
    botDifficulty: params.get("difficulty") || "medium",
    gameMode: gameMode
  });
} else {
  // Join existing room for join/spectate/global modes
  console.log("üö™ Joining room:", currentRoom);
  socket.emit("join_room", {
    room: currentRoom,
    playerName: playerName,
    gameMode: gameMode
  });
}

socket.on("room_created", startGame);
socket.on("game_joined", startGame);

function startGame(data){
  console.log("üéÆ startGame called with data:", data);
  
  // CRITICAL: Check data validity
  if (!data) {
    console.error("‚ùå No data received in startGame!");
    alert("Error: No game data received from server!");
    return;
  }
  
  if (!data.state) {
    console.error("‚ùå No state in data! Data keys:", Object.keys(data));
    alert("Error: Invalid game data received!");
    return;
  }
  
  if (!data.state.board) {
    console.error("‚ùå No board in state! State keys:", Object.keys(data.state));
    alert("Error: No board data in game state!");
    return;
  }
  
  if (!Array.isArray(data.state.board)) {
    console.error("‚ùå Board is not an array! Board type:", typeof data.state.board, "Value:", data.state.board);
    alert("Error: Invalid board format!");
    return;
  }
  
  console.log("‚úÖ Data validation passed");
  console.log("   Room:", data.room);
  console.log("   Color:", data.color);
  console.log("   Board:", data.state.board);
  
  document.getElementById("loadingMessage").style.display = "none";
  document.getElementById("game").style.display = "block";

  currentRoom = data.room;
  playerColor = data.color;
  gameState = data.state;

  updatePlayerNames(gameState);

  const roomName = document.getElementById("roomName");
  if (roomName) {
    if (playerColor === "spectator") {
      roomName.textContent = "üèõÔ∏è Room: " + currentRoom + " (Spectating)";
    } else {
      roomName.textContent = "üèõÔ∏è Room: " + currentRoom;
    }
  }

  const defaultSeconds = URL_TIME || 300;
  whiteSeconds = gameState.whiteTimeFormatted ? timeStringToSeconds(gameState.whiteTimeFormatted) : defaultSeconds;
  blackSeconds = gameState.blackTimeFormatted ? timeStringToSeconds(gameState.blackTimeFormatted) : defaultSeconds;

  updateDisplayedTimers();

  const isWaiting = (gameState.isActive === false);
  updateWaitingOverlay(isWaiting);

  if (!isWaiting) {
      startLocalTimer();
  }

  console.log("üìç About to call renderBoard...");
  renderBoard(gameState);
  console.log("üìç Finished renderBoard");
  
  updateStatus(gameState);
  updateTurnIndicator(gameState);
  
  // Hide control buttons for spectators
  if (playerColor === "spectator") {
    const buttons = document.querySelectorAll('.btn-draw, .btn-resign, #rematchBtn');
    buttons.forEach(btn => btn.style.display = 'none');

    // Completely hide chat section for spectators
    const chatCard = document.querySelector('.card:has(#chatMessages)');
    if (chatCard) {
      chatCard.style.display = 'none';
    }
  }
  
  // Update spectator count if provided
  if (data.spectatorCount !== undefined) {
    updateSpectatorCount(data.spectatorCount);
  }
  
  console.log("‚úÖ startGame completed");
}

socket.on("game_start", d=>{
  gameState = d.state;
  updateWaitingOverlay(false);
  updatePlayerNames(gameState);
  startLocalTimer();
  renderBoard(gameState);
  updateStatus(gameState);
  updateTurnIndicator(gameState);
  playSound("notify");
});

function updateWaitingOverlay(show) {
    const wrapper = document.getElementById("boardWrapper");
    let overlay = document.getElementById("waitingOverlay");
    if (show) {
        if (!overlay) {
            overlay = document.createElement("div");
            overlay.id = "waitingOverlay";
            overlay.className = "waiting-overlay";
            overlay.innerHTML = `
                <div class="waiting-spinner"></div>
                <div style="font-size:1.1em; margin-bottom:4px; font-weight:900;">Waiting for opponent...</div>
                <div style="font-size:0.8em; color:#ddd;">Room: ${currentRoom}</div>
            `;
            wrapper.appendChild(overlay);
        }
    } else {
        if (overlay) overlay.remove();
    }
}

socket.on("player_disconnected", (data) => {
    if (data.color !== playerColor) {
        const overlay = document.getElementById("disconnectOverlay");
        const timerSpan = document.getElementById("disconnectTimer");
        let timeLeft = data.timeout || 15;
        
        if (overlay && timerSpan) {
            overlay.classList.add("active");
            timerSpan.textContent = timeLeft;
            
            if (disconnectInterval) clearInterval(disconnectInterval);
            disconnectInterval = setInterval(() => {
                timeLeft--;
                timerSpan.textContent = timeLeft;
                if (timeLeft <= 0) {
                    clearInterval(disconnectInterval);
                }
            }, 1000);
        }
    }
});

socket.on("player_reconnected", (data) => {
    const overlay = document.getElementById("disconnectOverlay");
    if (overlay) overlay.classList.remove("active");
    if (disconnectInterval) clearInterval(disconnectInterval);
});

socket.on("game_update", d => {
  if (isDragging) {
    pendingUpdate = d;
    return;
  }
  const now = Date.now();
  if (d.lastMove && lastMoveWasMine && (now - lastMoveTime < 260)) {
    setTimeout(() => processGameUpdate(d), 260 - (now - lastMoveTime));
    return;
  }
  processGameUpdate(d);
});

function processGameUpdate(d) {
  const prev = gameState;
  const isMyMoveConfirmation = d.lastMove && lastMoveWasMine;
  
  const performUpdate = () => {
    const boardChanged = JSON.stringify(prev.board) !== JSON.stringify(d.state.board);
    gameState = d.state;

    updatePlayerNames(gameState);

    pendingMoves.clear();
    const SERVER_SYNC_THRESHOLD = 2;
    if (gameState.whiteTimeFormatted !== undefined) {
      const srv = timeStringToSeconds(gameState.whiteTimeFormatted);
      if (srv > 0 && Math.abs(srv - whiteSeconds) > SERVER_SYNC_THRESHOLD) {
        whiteSeconds = srv;
      }
    }
    if (gameState.blackTimeFormatted !== undefined) {
      const srv = timeStringToSeconds(gameState.blackTimeFormatted);
      if (srv > 0 && Math.abs(srv - blackSeconds) > SERVER_SYNC_THRESHOLD) {
        blackSeconds = srv;
      }
    }

    updateDisplayedTimers();
    
    if (gameState.winner) {
        const overlay = document.getElementById("disconnectOverlay");
        if (overlay) overlay.classList.remove("active");
        if (disconnectInterval) clearInterval(disconnectInterval);
    }

    if (boardChanged || !isMyMoveConfirmation) {
      if (d.lastMove) addMoveToHistory(d.lastMove, d.moveNotation);
      renderBoard(gameState, d.lastMove);
    } else {
      if (d.lastMove) addMoveToHistory(d.lastMove, d.moveNotation);
    }
    updateStatus(gameState);
    updateTurnIndicator(gameState);
  };

  if (isMyMoveConfirmation) {
    setTimeout(performUpdate, 0);
  } else {
    if (d.lastMove && !lastMoveWasMine) {
      const wasCapture = prev && prev.board && prev.board[d.lastMove.to.row] && prev.board[d.lastMove.to.row][d.lastMove.to.col] !== ".";
      playSound(wasCapture ? "capture" : "move");
    }
    performUpdate();
  }
  lastMoveWasMine = false;
}

function updatePlayerNames(state) {
  const whiteNameEl = document.getElementById("whitePlayerName");
  const blackNameEl = document.getElementById("blackPlayerName");
  
  if (whiteNameEl && state.whiteName) {
    whiteNameEl.textContent = state.whiteName;
  }
  if (blackNameEl && state.blackName) {
    blackNameEl.textContent = state.blackName;
  }
}

function applyOptimisticMove(from, to, promotion) {
  const optimistic = JSON.parse(JSON.stringify(gameState));
  const piece = optimistic.board[from.row][from.col];
  optimistic.board[to.row][to.col] = promotion ? (piece.toUpperCase() === piece ? promotion.toUpperCase() : promotion.toLowerCase()) : piece;
  optimistic.board[from.row][from.col] = ".";
  optimistic.turn = optimistic.turn === "white" ? "black" : "white";
  return optimistic;
}

function animateMove(from, to, callback) {
  requestAnimationFrame(callback);
}

function updateSpectatorCount(count) {
  const spectatorCount = document.getElementById("spectatorCount");
  if (spectatorCount) {
    if (count > 0) {
      spectatorCount.textContent = `üëÅÔ∏è ${count} watching`;
      spectatorCount.style.display = 'inline';
    } else {
      spectatorCount.style.display = 'none';
    }
  }
}

socket.on("spectator_joined", (data) => {
  updateSpectatorCount(data.spectatorCount);
});

socket.on("spectator_left", (data) => {
  updateSpectatorCount(data.spectatorCount);
});

// ===== RENDER BOARD (IMPROVED WITH SAFETY CHECKS) =====
function renderBoard(state, lastMove=null){
  console.log("üé® renderBoard called with state:", state);
  
  const board=document.getElementById("chessboard");
  if (!board) {
    console.error("‚ùå Chessboard element not found!");
    return;
  }
  
  // CRITICAL: Check if state and state.board exist
  if (!state) {
    console.error("‚ùå No state provided to renderBoard!");
    return;
  }
  
  if (!state.board) {
    console.error("‚ùå No board in state! State keys:", Object.keys(state));
    return;
  }
  
  if (!Array.isArray(state.board) || state.board.length !== 8) {
    console.error("‚ùå Invalid board format! Board:", state.board);
    return;
  }
  
  console.log("‚úÖ Rendering board. First row:", state.board[0]);
  
  board.innerHTML="";
  const flipped = (playerColor === "black");
  const rows = flipped ? [...Array(8).keys()].reverse() : [...Array(8).keys()];
  const cols = flipped ? [...Array(8).keys()].reverse() : [...Array(8).keys()];
  
  for (let r of rows){
    for (let c of cols){
      const sq=document.createElement("div");
      sq.className=`square ${(r+c)%2===0?"light":"dark"}`;
      sq.dataset.row=r;
      sq.dataset.col=c;

      const isBottom = (playerColor === "black") ? (r === 0) : (r === 7);
      const isLeft = (playerColor === "black") ? (c === 7) : (c === 0);

      if (isBottom) {
          const fileLabel = document.createElement("div");
          fileLabel.className = "square-coord file";
          fileLabel.textContent = String.fromCharCode(97 + c);
          sq.appendChild(fileLabel);
      }
      if (isLeft) {
          const rankLabel = document.createElement("div");
          rankLabel.className = "square-coord rank";
          rankLabel.textContent = (8 - r).toString();
          sq.appendChild(rankLabel);
      }

      if(lastMove){
        const fm=lastMove.from, to=lastMove.to;
        if((fm.row===r && fm.col===c)||(to.row===r && to.col===c)){
          sq.classList.add("last-move");
        }
      }
      if(selectedSquare && selectedSquare.row===r && selectedSquare.col===c){
        sq.classList.add("selected");
      }
      if(possibleMoves.some(m=>m.row===r && m.col===c)){
        sq.classList.add("possible-move");
      }
      
      // CRITICAL: Check if board[r] exists before accessing board[r][c]
      if (!state.board[r]) {
        console.error(`‚ùå Board row ${r} is undefined!`);
        continue;
      }
      
      const piece = state.board[r][c];
      if(piece !== "."){
        const pDiv=document.createElement("div");
        pDiv.className="piece";
        const isWhitePiece = piece === piece.toUpperCase();
        const color = isWhitePiece ? "white" : "black";
        
        // Only allow dragging for the player's own pieces, not for spectators
        if(color === state.turn && color === playerColor && playerColor !== "spectator"){
          pDiv.draggable=true;
        }
        pDiv.dataset.row=r;
        pDiv.dataset.col=c;
        
        pDiv.addEventListener("dragstart", e=>{
          isDragging = true;
          selectedSquare = { row:r, col:c };
          
          const key = `${r},${c}`;
          possibleMoves = (state.moves && state.moves[key]) ? state.moves[key] : [];

          e.target.style.opacity = '0';
          
          const dragImg = e.target.cloneNode(true);
          dragImg.style.opacity = '1';
          dragImg.style.position = 'absolute';
          dragImg.style.top = '-1000px';
          dragImg.style.width = e.target.offsetWidth + 'px';
          dragImg.style.height = e.target.offsetHeight + 'px';
          document.body.appendChild(dragImg);
          const offsetX = e.target.offsetWidth / 2;
          const offsetY = e.target.offsetHeight / 2;
          e.dataTransfer.setDragImage(dragImg, offsetX, offsetY);
          setTimeout(() => dragImg.remove(), 0);

          document.querySelectorAll('.square').forEach(s => {
             s.classList.remove('selected', 'possible-move');
          });

          possibleMoves.forEach(m => {
             const targetSq = document.querySelector(`.square[data-row="${m.row}"][data-col="${m.col}"]`);
             if(targetSq) targetSq.classList.add('possible-move');
          });
          
          e.dataTransfer.setData("fromRow", r);
          e.dataTransfer.setData("fromCol", c);
        });

        pDiv.addEventListener("dragend", (e) => {
             e.target.style.opacity = '1';
             isDragging = false;
             selectedSquare = null;
             possibleMoves = [];
             if (pendingUpdate) {
               processGameUpdate(pendingUpdate);
               pendingUpdate = null;
             } else {
               renderBoard(gameState, lastMove);
             }
        });

        const img=document.createElement("img");
        const clr = isWhitePiece ? "w" : "b";
        const type = piece.toLowerCase();
        img.src=`https://images.chesscomfiles.com/chess-themes/pieces/neo/150/${clr}${type}.png`;
        img.onerror = function() {
          console.error(`‚ùå Failed to load piece image: ${img.src}`);
        };
        pDiv.appendChild(img);
        sq.appendChild(pDiv);
      }

      // Click handlers
      sq.addEventListener("click", ()=> handleSquareClick(r,c,state));

      // Drag and Drop handlers
      sq.addEventListener("dragover", (e) => {
        e.preventDefault();
      });

      sq.addEventListener("drop", (e) => {
        e.preventDefault();
        const fr = parseInt(e.dataTransfer.getData("fromRow"));
        const fc = parseInt(e.dataTransfer.getData("fromCol"));
        const from = { row: fr, col: fc };
        const to = { row: r, col: c };

        if (!isNaN(fr) && !isNaN(fc)) {
          const movingPiece = state.board[fr][fc];
          const isPawn = movingPiece.toLowerCase() === "p";
          const isPromoRank = (playerColor === "white" && r === 0) ||
                              (playerColor === "black" && r === 7);
          if (isPawn && isPromoRank) {
            pendingPromotion = { from, to };
            showPromotionModal(playerColor);
          } else {
            makeMove(from,to,null,true);
          }
        }
      });
      board.appendChild(sq);
    }
  }
  
  console.log("‚úÖ Board rendered successfully");
}

function handleSquareClick(row, col, state){
  if(state.winner) return;
  
  // Prevent spectators from making moves
  if (playerColor === "spectator") {
    const messages = document.getElementById("messages");
    if (messages) messages.textContent = "üëÅÔ∏è You are spectating";
    return;
  }
  
  if (state.isActive === false) {
    const messages = document.getElementById("messages");
    if (messages) messages.textContent = "‚è≥ Waiting for opponent...";
    return;
  }
  if(state.turn !== playerColor){
    const messages = document.getElementById("messages");
    if (messages) messages.textContent = "‚è≥ Wait for your turn!";
    return;
  }
  const piece = state.board[row][col];
  const isWhite = piece !== "." && piece === piece.toUpperCase();
  const isMine = piece !== "." && (
    (playerColor==="white" && isWhite) ||
    (playerColor==="black" && !isWhite)
  );
  
  if(isMine){
    selectedSquare = { row,col };
    const key = `${row},${col}`;
    possibleMoves = (state.moves && state.moves[key]) ? state.moves[key] : [];
    
    renderBoard(state);
    
    const messages = document.getElementById("messages");
    if (messages) messages.textContent="";
    return;
  }

  if(!selectedSquare) return;
  const isValid = possibleMoves.some(m=>m.row===row && m.col===col);
  if(!isValid){
    const messages = document.getElementById("messages");
    if (messages) messages.textContent = "‚ùå Invalid move!";
    return;
  }
  const movingPiece = state.board[selectedSquare.row][selectedSquare.col];
  const isPawn = movingPiece.toLowerCase()==="p";
  const isPromoRank = (playerColor==="white" && row===0) ||
                      (playerColor==="black" && row===7);
  if(isPawn && isPromoRank){
    pendingPromotion = { from:selectedSquare, to:{row,col} };
    showPromotionModal(playerColor);
  } else {
    makeMove(selectedSquare, {row,col}, null);
  }
}

function makeMove(from, to, promotion=null, isDrop=false){
  lastMoveWasMine = true;
  lastMoveTime = Date.now();
  const moveId = ++moveSequence;
  const previousState = JSON.parse(JSON.stringify(gameState));
  
  selectedSquare = null;
  possibleMoves = [];
  pendingPromotion = null;
  
  const performMove = () => {
    const optimisticState = applyOptimisticMove(from, to, promotion);
    if (optimisticState) {
      gameState = optimisticState;
      renderBoard(gameState, { from, to });
      updateTurnIndicator(gameState);
      const wasCapture = previousState.board[to.row][to.col] !== ".";
      playSound(wasCapture ? "capture" : "move");
      pendingMoves.set(moveId, {
        from, to, promotion, previousState, timestamp: Date.now()
      });
    }
  };

  if (!isDrop) {
    animateMove(from, to, performMove);
  } else {
    performMove();
  }

  socket.emit("move", { room: currentRoom, from, to, promotion, moveId });
  const messages = document.getElementById("messages");
  if (messages) messages.textContent = "";
}

function showPromotionModal(color){
  const modal=document.getElementById("promotionModal");
  const pcs=document.getElementById("promotionPieces");
  if (!modal || !pcs) return;
  pcs.innerHTML="";
  const opt=['q','r','b','n'];
  const pre = (color==="white") ? "w" : "b";
  opt.forEach(t=>{
    const img=document.createElement("img");
    img.src=`https://images.chesscomfiles.com/chess-themes/pieces/neo/150/${pre}${t}.png`;
    img.onclick = ()=>{
      makeMove(pendingPromotion.from, pendingPromotion.to, t);
      modal.classList.remove("active");
    };
    pcs.appendChild(img);
  });
  modal.classList.add("active");
}

function cancelPromotion(){
  pendingPromotion=null;
  const modal = document.getElementById("promotionModal");
  if (modal) modal.classList.remove("active");
}

function addMoveToHistory(lastMove,notation){
  moveHistory.push({ from:lastMove.from, to:lastMove.to, notation: notation });
  renderMoveHistory();
}

function renderMoveHistory(){
  const list=document.getElementById("moveList");
  if (!list) return;
  list.innerHTML="";
  for(let i=0;i<moveHistory.length;i+=2){
    const num=document.createElement("div");
    num.className="move-number";
    num.textContent=(i/2+1)+".";
    list.appendChild(num);
    const w=document.createElement("div");
    w.className="move-item white";
    w.textContent=moveHistory[i].notation;
    list.appendChild(w);
    if(i+1 < moveHistory.length){
      const b=document.createElement("div");
      b.className="move-item black";
      b.textContent=moveHistory[i+1].notation;
      list.appendChild(b);
    } else {
      list.appendChild(document.createElement("div"));
    }
  }
  const parent = list.parentElement;
  if (parent) parent.scrollTop = parent.scrollHeight;
}

function updateTurnIndicator(state){
  const ind=document.getElementById("turnIndicator");
  if (!ind) return;
  if(state.winner){
    ind.textContent="üèÅ Game Over";
    ind.style.background="linear-gradient(135deg, #11998e 0%, #38ef7d 100%)";
    ind.style.color="#fff";
    return;
  }
  ind.textContent = (state.turn==="white") ? "‚ôî White to move" : "‚ôö Black to move";
  ind.style.background = "";
  ind.style.color = "";
}

function updateStatus(state){
  const s=document.getElementById("status");
  const rematchBtn = document.getElementById("rematchBtn");
  const drawBtn = document.querySelector(".btn-draw");
  const resignBtn = document.querySelector(".btn-resign");

  if (!s) return;

  if(state.winner){
    if (rematchBtn) {
        rematchBtn.classList.add("active");
        rematchBtn.disabled = false;
    }

    // Disable Draw and Resign buttons when game is over
    if (drawBtn) {
        drawBtn.disabled = true;
        drawBtn.style.opacity = "0.5";
        drawBtn.style.cursor = "not-allowed";
    }
    if (resignBtn) {
        resignBtn.disabled = true;
        resignBtn.style.opacity = "0.5";
        resignBtn.style.cursor = "not-allowed";
    }

    if(state.winner==="draw"){
      s.textContent="ü§ù Game Draw!";
      s.style.background="linear-gradient(135deg, #f7971e 0%, #ffd200 100%)";
      s.style.color="#fff";
    } else {
      const w = state.winner==="white" ? "‚ôî WHITE" : "‚ôö BLACK";
      const r =
        state.reason==="checkmate" ? "by Checkmate" :
        state.reason==="resign" ? "by Resignation" :
        state.reason==="timeout" ? "by Timeout" :
        state.reason==="abandonment" ? "by Abandonment" : "";
      s.textContent=`üëë ${w} Wins ${r}!`;
      s.style.background="linear-gradient(135deg, #11998e 0%, #38ef7d 100%)";
      s.style.color="#fff";
    }
    return;
  }

  if (rematchBtn) {
      rematchBtn.classList.remove("active");
  }

  // Re-enable Draw and Resign buttons when game is active
  if (drawBtn) {
      drawBtn.disabled = false;
      drawBtn.style.opacity = "1";
      drawBtn.style.cursor = "pointer";
  }
  if (resignBtn) {
      resignBtn.disabled = false;
      resignBtn.style.opacity = "1";
      resignBtn.style.cursor = "pointer";
  }

  if(state.check){
    const t = state.turn==="white"?"‚ôî WHITE":"‚ôö BLACK";
    s.textContent=`‚ö†Ô∏è CHECK! ${t}'s turn`;
    s.style.background="linear-gradient(135deg, #eb3349 0%, #f45c43 100%)";
    s.style.color="#fff";
    return;
  }
  s.textContent="\u00A0";
  s.style.background="rgba(102, 126, 234, 0.1)";
  s.style.color="#333";
}

function goHome(){
  if(confirm("Return to home? Current game will end.")){
    socket.emit("leave_room",{room:currentRoom});
    window.location.href = "/";
  }
}

function offerDraw(){
  socket.emit("offer_draw",{room:currentRoom,color:playerColor});
  const messages = document.getElementById("messages");
  if (messages) messages.textContent="ü§ù Draw offer sent...";
}

socket.on("draw_offered", data=>{
  // Don't show draw modal to spectators
  if (playerColor === "spectator") return;

  const drawMessage = document.getElementById("drawMessage");
  const drawModal = document.getElementById("drawModal");
  if (drawMessage && drawModal) {
    drawMessage.textContent = `${data.fromColor.toUpperCase()} offers a draw. Accept?`;
    drawModal.classList.add("active");
  }
});

socket.on("draw_declined", ()=>{
  const messages = document.getElementById("messages");
  if (messages) messages.textContent="‚ùå Opponent declined your draw.";
});

function respondToDraw(acc){
  const drawModal = document.getElementById("drawModal");
  if (drawModal) drawModal.classList.remove("active");
  socket.emit("respond_draw",{room:currentRoom,accept:acc});
}

function resignGame(){
  if(confirm("Are you sure you want to resign?")){
    socket.emit("resign",{room:currentRoom,color:playerColor});
  }
}

// ===== CHAT =====
const chatInput = document.getElementById("chatInput");
const chatMessages = document.getElementById("chatMessages");
let typingTimeout;

chatInput.addEventListener("input", () => {
  socket.emit("typing", { room: currentRoom, sender: playerColor });
  clearTimeout(typingTimeout);
  typingTimeout = setTimeout(() => {
    socket.emit("stop_typing", { room: currentRoom, sender: playerColor });
  }, 1000);
});

chatInput.addEventListener("keypress", (e) => {
  if (e.key === "Enter") {
    sendMessage();
  }
});

function sendMessage() {
  const msg = chatInput.value.trim();
  if (!msg) return;
  socket.emit("send_message", { room: currentRoom, sender: playerColor, message: msg });
  chatInput.value = "";
  socket.emit("stop_typing", { room: currentRoom, sender: playerColor });
}

socket.on("chat_message", (data) => {
  const msgDiv = document.createElement("div");
  msgDiv.className = `chat-message ${data.sender}`;
  const senderName = data.sender === "white" ? (gameState?.whiteName || "White") : (gameState?.blackName || "Black");
  msgDiv.innerHTML = `<strong>${senderName}:</strong> ${escapeHtml(data.message)}`;
  chatMessages.appendChild(msgDiv);
  chatMessages.scrollTop = chatMessages.scrollHeight;
});

socket.on("user_typing", (data) => {
  const typingIndicator = document.getElementById("typingIndicator");
  if (typingIndicator && data.sender !== playerColor) {
    typingIndicator.classList.add("active");
  }
});

socket.on("user_stop_typing", (data) => {
  const typingIndicator = document.getElementById("typingIndicator");
  if (typingIndicator) {
    typingIndicator.classList.remove("active");
  }
});

function escapeHtml(text) {
  const div = document.createElement('div');
  div.textContent = text;
  return div.innerHTML;
}

// Simple emoji picker
const emojiToggle = document.getElementById("emojiToggle");
const emojis = ["üòä", "üòÇ", "üëç", "‚ù§Ô∏è", "üéâ", "üòé", "ü§î", "üò≠"];
let emojiIndex = 0;

emojiToggle.addEventListener("click", () => {
  chatInput.value += emojis[emojiIndex];
  emojiIndex = (emojiIndex + 1) % emojis.length;
  chatInput.focus();
});
</script>
</body>
</html>
