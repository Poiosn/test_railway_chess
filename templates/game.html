<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Chess Master ‚Äî Premium Edition</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
  <style>
    /* static/style.css content embedded */
    * { margin:0; padding:0; box-sizing:border-box; }

    /* STATIC LIGHT SKY BLUE BACKGROUND */
    body {
      font-family:'Inter','Segoe UI','Helvetica Neue',sans-serif;
      background: #87CEEB;
      min-height:100vh;
      display:flex;
      justify-content:center;
      align-items:center;
      padding:20px;
      position:relative;
      overflow-x:hidden;
      user-select: none;
      -webkit-user-select: none;
    }

    /* GLASSMORPHISM CONTAINER */
    .container{
      background: rgba(255, 255, 255, 0.25);
      backdrop-filter: blur(20px) saturate(180%);
      -webkit-backdrop-filter: blur(20px) saturate(180%);
      border: 1px solid rgba(255, 255, 255, 0.3);
      border-radius: 32px;
      box-shadow: 
        0 8px 32px 0 rgba(31, 38, 135, 0.37),
        inset 0 1px 0 0 rgba(255, 255, 255, 0.5);
      padding:28px;
      width:98vw;
      max-width:1800px;
      height:auto;
      max-height:92vh;
      position:relative;
      z-index:1;
      overflow-y:auto;
      animation: containerFadeIn 0.6s ease;
    }

    @keyframes containerFadeIn {
      from { opacity: 0; transform: translateY(20px); }
      to { opacity: 1; transform: translateY(0); }
    }

    /* PREMIUM TITLE WITH SHINE EFFECT */
    h1 {
      text-align:center;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 50%, #f093fb 100%);
      background-size: 200% auto;
      -webkit-background-clip:text;
      -webkit-text-fill-color:transparent;
      background-clip:text;
      font-size:36px;
      font-weight:900;
      margin-bottom:8px;
      letter-spacing:-1.5px;
      animation: titleShine 3s linear infinite;
      text-shadow: 0 0 30px rgba(102, 126, 234, 0.3);
    }

    @keyframes titleShine {
      to { background-position: 200% center; }
    }

    .subtitle {
      text-align:center;
      color:#555;
      margin-bottom:14px;
      font-size:13px;
      font-weight:500;
      letter-spacing: 0.5px;
    }

    /* ENHANCED CONNECTION STATUS */
    .connection-status {
      text-align:center;
      padding:10px 20px;
      margin-bottom:12px;
      border-radius:16px;
      font-weight:700;
      font-size:13px;
      transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: 0 4px 15px rgba(0,0,0,0.1);
    }
    .connection-status.connected {
      background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
      color: white;
      animation: pulse 2s ease-in-out infinite;
    }
    .connection-status.disconnected {
      background: linear-gradient(135deg, #eb3349 0%, #f45c43 100%);
      color: white;
    }

    @keyframes pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.02); }
    }

    /* ENHANCED GAME INFO CARD */
    .game-info {
      text-align:center;
      margin-bottom: 10px;
      padding:16px;
      background: rgba(255, 255, 255, 0.6);
      backdrop-filter: blur(10px);
      border-radius:16px;
      border: 1px solid rgba(255, 255, 255, 0.8);
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.1);
      transition: transform 0.3s ease;
    }
    .game-info:hover {
      transform: translateY(-2px);
      box-shadow: 0 12px 30px rgba(0, 0, 0, 0.15);
    }

    .game-info h3 {
      font-size: 18px;
      font-weight: 800;
      color: #333;
      margin-bottom: 8px;
    }

    /* PREMIUM PLAYER BADGES */
    .player-badge {
      padding: 6px 16px;
      border-radius: 20px;
      font-weight: 800;
      font-size: 14px;
      display: inline-block;
      transition: all 0.3s ease;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.15);
    }
    .player-badge.white {
      background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
      border: 2px solid #e0e0e0;
      color: #333;
    }
    .player-badge.black {
      background: linear-gradient(135deg, #434343 0%, #000000 100%);
      color: #fff;
      border: 2px solid #666;
    }
    .player-badge:hover {
      transform: scale(1.05);
    }

    .room-controls {
      display:flex;
      gap:12px;
      margin-bottom:12px;
      justify-content:center;
      flex-wrap:wrap;
    }
    .bot-controls {
      text-align:center;
      margin-bottom:16px;
    }

    /* PREMIUM TIME CONTROL SECTION */
    .time-control-section {
      text-align:center;
      margin-bottom:16px;
      padding:18px;
      background: linear-gradient(135deg, rgba(224, 247, 250, 0.8) 0%, rgba(178, 235, 242, 0.8) 100%);
      backdrop-filter: blur(10px);
      border-radius:16px;
      border: 1px solid rgba(255, 255, 255, 0.6);
      box-shadow: 0 8px 20px rgba(0, 105, 92, 0.1);
    }
    .time-control-section h4 {
      color: #00695c;
      margin-bottom: 12px;
      font-size: 15px;
      font-weight: 800;
    }
    .time-options {
      display:flex;
      gap:10px;
      justify-content:center;
      flex-wrap:wrap;
    }

    /* PREMIUM TIME BUTTONS */
    .time-btn {
      padding: 10px 18px;
      background: white;
      border: 2px solid #00897b;
      border-radius: 12px;
      cursor: pointer;
      font-weight: 700;
      font-size: 14px;
      color: #00695c;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: 0 4px 10px rgba(0, 137, 123, 0.2);
      position: relative;
      overflow: hidden;
    }
    .time-btn::before {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 0;
      height: 0;
      border-radius: 50%;
      background: rgba(0, 137, 123, 0.2);
      transform: translate(-50%, -50%);
      transition: width 0.6s, height 0.6s;
    }
    .time-btn:hover::before {
      width: 300px;
      height: 300px;
    }
    .time-btn:hover {
      background: #00897b;
      color: white;
      transform: translateY(-2px);
      box-shadow: 0 8px 20px rgba(0, 137, 123, 0.3);
    }
    .time-btn.selected {
      background: linear-gradient(135deg, #00695c 0%, #004d40 100%);
      color: white;
      border-color: #004d40;
      box-shadow: 0 6px 20px rgba(0, 105, 92, 0.4);
    }

    /* PREMIUM INPUT FIELDS */
    input[type="text"] {
      flex:1;
      max-width:none;
      min-width:200px;
      padding:14px 20px;
      border: 2px solid rgba(102, 126, 234, 0.3);
      border-radius:14px;
      font-size:15px;
      font-family: 'Inter', sans-serif;
      transition: all 0.3s ease;
      background: rgba(255, 255, 255, 0.9);
      backdrop-filter: blur(10px);
      user-select: text;
      -webkit-user-select: text;
    }
    input[type="text"]:focus {
      outline: none;
      border-color: #667eea;
      box-shadow: 0 0 0 4px rgba(102, 126, 234, 0.1), 0 8px 20px rgba(102, 126, 234, 0.2);
      transform: translateY(-2px);
    }

    /* PREMIUM BUTTONS */
    button {
      padding: 14px 24px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
      border-radius: 14px;
      cursor: pointer;
      font-weight: 700;
      font-size: 15px;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: 0 6px 20px rgba(102, 126, 234, 0.3);
      position: relative;
      overflow: hidden;
    }
    button::after {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 0;
      height: 0;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.3);
      transform: translate(-50%, -50%);
      transition: width 0.6s, height 0.6s;
    }
    button:hover::after {
      width: 300px;
      height: 300px;
    }
    button:hover {
      transform: translateY(-3px);
      box-shadow: 0 10px 30px rgba(102, 126, 234, 0.4);
    }
    button:active {
      transform: translateY(-1px);
    }
    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none !important;
    }

    .btn-bot {
      background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
      box-shadow: 0 6px 20px rgba(17, 153, 142, 0.3);
    }
    .btn-secondary {
      background: linear-gradient(135deg, #bdc3c7 0%, #2c3e50 100%);
      box-shadow: 0 6px 20px rgba(44, 62, 80, 0.3);
    }
    .btn-danger {
      background: linear-gradient(135deg, #eb3349 0%, #f45c43 100%);
      box-shadow: 0 6px 20px rgba(235, 51, 73, 0.3);
    }
    .btn-draw {
      background: linear-gradient(135deg, #f7971e 0%, #ffd200 100%);
      box-shadow: 0 6px 20px rgba(247, 151, 30, 0.3);
    }

    /* ENHANCED TIMER WITH PROGRESS BAR */
    .timer {
      padding: 8px 16px;
      border-radius: 12px;
      text-align: center;
      font-size: 16px;
      font-weight: 800;
      transition: all 0.3s ease;
      position: absolute;
      backdrop-filter: blur(10px);
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
      min-width: 80px;
    }
    .timer.white {
      background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
      border: 2px solid #e0e0e0;
      color: #333;
    }
    .timer.black {
      background: linear-gradient(135deg, #434343 0%, #000000 100%);
      color: #fff;
      border: 2px solid #666;
    }
    .timer.active {
      box-shadow: 0 0 30px rgba(102, 126, 234, 0.8), 0 4px 15px rgba(0, 0, 0, 0.3);
      transform: scale(1.08);
      animation: timerPulse 1.5s ease-in-out infinite;
    }

    @keyframes timerPulse {
      0%, 100% { transform: scale(1.08); }
      50% { transform: scale(1.12); }
    }

    /* === NEW: PLAYER NAME STYLES === */
    .player-name {
      padding: 8px 24px;
      border-radius: 12px;
      text-align: center;
      font-size: 16px;
      font-weight: 700;
      position: absolute;
      backdrop-filter: blur(10px);
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
      min-width: 140px;
      max-width: 300px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      right: 0;
    }
    .player-name.white {
      background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
      border: 2px solid #e0e0e0;
      color: #333;
    }
    .player-name.black {
      background: linear-gradient(135deg, #434343 0%, #000000 100%);
      color: #fff;
      border: 2px solid #666;
    }

    .board-wrapper {
      position: relative;
      margin-top: 10px;
      margin-bottom: 10px;
    }

    .board-section {
      position: relative;
      width: 100%;
      max-width: 700px;
      margin: 0 auto;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    /* 3D ENHANCED CHESSBOARD */
    .chessboard {
      display: grid;
      grid-template-columns: repeat(8, 1fr);
      width: min(92vw, 700px);
      aspect-ratio: 1 / 1;
      height: auto;
      border: 6px solid rgba(44, 62, 80, 0.8);
      border-radius: 12px;
      overflow: hidden;
      box-shadow: 
        0 20px 60px rgba(0, 0, 0, 0.4),
        inset 0 1px 0 rgba(255, 255, 255, 0.2);
      position: relative;
      transform-style: preserve-3d;
      perspective: 1000px;
    }

    /* === NEW: WAITING OVERLAY STYLES === */
    .waiting-overlay {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.6);
      backdrop-filter: blur(5px);
      z-index: 100;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      border-radius: 12px;
      color: white;
      font-weight: bold;
      animation: fadeIn 0.3s;
    }
    
    /* === NEW: DISCONNECT OVERLAY STYLES === */
    .disconnect-overlay {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(220, 38, 38, 0.8);
      backdrop-filter: blur(5px);
      z-index: 101;
      display: none; /* Hidden by default */
      flex-direction: column;
      align-items: center;
      justify-content: center;
      border-radius: 12px;
      color: white;
      font-weight: bold;
      animation: fadeIn 0.3s;
      text-align: center;
      padding: 20px;
    }
    .disconnect-overlay.active {
      display: flex;
    }
    
    .waiting-spinner {
      border: 4px solid rgba(255,255,255,0.3);
      border-top: 4px solid #fff;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      animation: spin 1s linear infinite;
      margin-bottom: 15px;
    }
    @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    @keyframes fadeIn { from { opacity:0; } to { opacity:1; } }
    /* ================================== */

    .square-coord {
      position: absolute;
      font-size: 11px;
      font-weight: 800;
      pointer-events: none;
      user-select: none;
      opacity: 0.7;
      z-index: 5;
    }
    .square-coord.file {
      bottom: 2px;
      right: 4px;
    }
    .square-coord.rank {
      top: 2px;
      left: 4px;
    }
    .square.light .square-coord { color: #b58863; }
    .square.dark .square-coord { color: #f0d9b5; }

    /* ENHANCED SQUARES WITH DEPTH */
    .square {
      aspect-ratio: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
      position: relative;
    }
    .square::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.15), transparent);
      opacity: 0;
      transition: opacity 0.3s ease;
    }
    .square:hover::before {
      opacity: 1;
    }
    .square.light {
      background: linear-gradient(135deg, #f5e6d3 0%, #f0d9b5 100%);
    }
    .square.dark {
      background: linear-gradient(135deg, #c9a882 0%, #b58863 100%);
    }
    .square.selected {
      background: radial-gradient(circle, #baca44 0%, #a8b834 100%) !important;
      box-shadow: inset 0 0 30px rgba(0, 0, 0, 0.4);
      animation: selectedGlow 1s ease-in-out infinite;
    }

    @keyframes selectedGlow {
      0%, 100% { box-shadow: inset 0 0 30px rgba(0, 0, 0, 0.4), 0 0 20px rgba(186, 202, 68, 0.6); }
      50% { box-shadow: inset 0 0 30px rgba(0, 0, 0, 0.4), 0 0 30px rgba(186, 202, 68, 0.8); }
    }

    /* ANIMATED MOVE INDICATORS */
    .square.possible-move::after {
      content: '';
      position: absolute;
      width: 35%;
      height: 35%;
      background: radial-gradient(circle, rgba(34, 197, 94, 0.6), rgba(34, 197, 94, 0.3));
      border-radius: 50%;
      animation: moveIndicator 1.5s ease-in-out infinite;
      box-shadow: 0 0 15px rgba(34, 197, 94, 0.5);
    }

    @keyframes moveIndicator {
      0%, 100% { transform: scale(1); opacity: 0.7; }
      50% { transform: scale(1.2); opacity: 1; }
    }

    .square.last-move {
      background: radial-gradient(circle, #ffd93d 0%, #cdd26a 100%) !important;
      box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.2);
    }
    .square:hover {
      filter: brightness(1.15);
      transform: scale(1.02);
    }

    /* 3D PIECE EFFECTS */
    .piece {
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
      transform-style: preserve-3d;
      cursor: grab;
    }
    .piece:active {
      cursor: grabbing;
    }
    .piece.moving {
      opacity: 0.7;
      transform: scale(0.95);
    }

    .piece img {
      width: 88%;
      height: 88%;
      object-fit: contain;
      pointer-events: none;
      filter: drop-shadow(0 2px 8px rgba(0, 0, 0, 0.3));
      transition: filter 0.3s ease;
    }

    /* ENHANCED MOVE HISTORY */
    .move-history {
      background: rgba(255, 255, 255, 0.6);
      backdrop-filter: blur(10px);
      border-radius: 16px;
      padding: 14px;
      height: 700px;
      overflow-y: scroll;
      min-width: 0;
      border: 1px solid rgba(255, 255, 255, 0.8);
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.1);
    }
    .move-history h4 {
      color: #2c3e50;
      margin-bottom: 12px;
      font-size: 15px;
      font-weight: 800;
      position: sticky;
      top: 0;
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(10px);
      padding: 10px 8px;
      border-bottom: 2px solid rgba(102, 126, 234, 0.3);
      border-radius: 8px 8px 0 0;
      z-index: 10;
      margin-left: -14px;
      margin-right: -14px;
      margin-top: -14px;
      padding-left: 14px;
      padding-right: 14px;
    }
    
    .move-list {
      display: grid;
      grid-template-columns: 45px minmax(0, 1fr) minmax(0, 1fr);
      gap: 10px;
      font-size: 14px;
      margin-top: 10px;
    }
    .move-number {
      color: #666;
      font-weight: 800;
      text-align: right;
      padding-right: 10px;
    }
    .move-item {
      background: rgba(248, 249, 250, 0.8);
      backdrop-filter: blur(5px);
      padding: 6px 10px;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s ease;
      font-weight: 600;
      text-align: center;
      overflow: hidden;
      min-width: 0; /* Prevents grid item from expanding with long content */
    }
    .move-item:hover {
      background: rgba(102, 126, 234, 0.15);
      transform: translateX(3px);
    }
    .move-item.white {
      border-left: 3px solid #e0e0e0;
    }
    .move-item.black {
      border-left: 3px solid #333;
    }

    /* ENHANCED TURN INDICATOR */
    .turn-indicator {
      text-align: center;
      padding: 8px;
      border-radius: 14px;
      font-size: 15px;
      font-weight: 800;
      margin-bottom: 6px;
      transition: all 0.3s ease;
      background: rgba(255, 255, 255, 0.6);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.8);
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
    }

    /* PREMIUM STATUS BANNERS */
    .status {
      min-height: 30px;
      text-align: center;
      padding: 12px;
      margin-top: 14px;
      border-radius: 14px;
      font-size: 16px;
      font-weight: 800;
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);
      backdrop-filter: blur(10px);
      animation: statusAppear 0.5s ease;
    }

    @keyframes statusAppear {
      from { opacity: 0; transform: translateY(-10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .button-group {
      display: flex;
      justify-content: center;
      gap: 14px;
      margin-top: 20px;
      flex-wrap: wrap;
    }
    .button-group button {
      border-radius: 14px;
      padding: 14px 28px;
      font-size: 15px;
      font-weight: 700;
    }

    /* ENHANCED MODALS */
    .promotion-modal,
    .draw-modal,
    .name-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      display: none;
      align-items: center;
      justify-content: center;
      background: rgba(0, 0, 0, 0.7);
      backdrop-filter: blur(8px);
      z-index: 9999;
      animation: modalFadeIn 0.3s ease;
    }

    @keyframes modalFadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    .promotion-modal.active,
    .draw-modal.active,
    .name-modal.active {
      display: flex;
    }

    .promotion-content,
    .draw-content,
    .name-content {
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(20px);
      padding: 28px;
      border-radius: 20px;
      text-align: center;
      min-width: 320px;
      border: 1px solid rgba(255, 255, 255, 0.8);
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4);
      animation: modalSlideIn 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    }

    @keyframes modalSlideIn {
      from {
        opacity: 0;
        transform: translateY(-40px) scale(0.9);
      }
      to {
        opacity: 1;
        transform: translateY(0) scale(1);
      }
    }

    .promotion-content h3,
    .draw-content h3,
    .name-content h3 {
      font-size: 22px;
      font-weight: 900;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      margin-bottom: 10px;
    }

    .promotion-pieces img {
      width: 75px;
      height: 75px;
      margin: 10px;
      cursor: pointer;
      transition: all 0.3s ease;
      filter: drop-shadow(0 4px 10px rgba(0, 0, 0, 0.2));
    }
    .promotion-pieces img:hover {
      transform: scale(1.15) translateY(-5px);
      filter: drop-shadow(0 8px 20px rgba(0, 0, 0, 0.4));
    }
    .promotion-pieces {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 10px;
      margin-top: 16px;
    }

    /* ENHANCED CHAT */
    .chat-box {
      background: rgba(255, 255, 255, 0.6);
      backdrop-filter: blur(10px);
      border-radius: 16px;
      padding: 12px;
      border: 1px solid rgba(255, 255, 255, 0.8);
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.1);
      min-width: 0;
    }
    .chat-box h4 {
      color: #2c3e50;
      margin-bottom: 10px;
      font-size: 15px;
      font-weight: 800;
    }
    .chat-messages {
      height: 220px;
      overflow-y: auto;
      padding: 8px;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .chat-line {
      padding: 10px 12px;
      border-radius: 12px;
      max-width: 85%;
      word-break: break-word;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      animation: chatAppear 0.3s ease;
      font-size: 13px;
      font-weight: 500;
      user-select: text;
      -webkit-user-select: text;
    }

    @keyframes chatAppear {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .chat-line.you {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      align-self: flex-end;
    }
    .chat-line.opponent {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      align-self: flex-start;
    }
    
    .typing-indicator {
      height: 20px;
      font-size: 12px;
      color: #666;
      margin-top: 8px;
      font-style: italic;
    }

    .chat-input {
      display: flex;
      gap: 8px;
      margin-top: 10px;
      align-items: center;
    }
    .chat-input input {
      flex: 1;
      padding: 12px;
      border-radius: 12px;
      border: 2px solid rgba(102, 126, 234, 0.3);
      background: rgba(255, 255, 255, 0.9);
      backdrop-filter: blur(10px);
      transition: all 0.3s ease;
    }
    .chat-input input:focus {
      outline: none;
      border-color: #667eea;
      box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
    }
    .chat-input button {
      padding: 12px 16px;
      border-radius: 12px;
    }

    .emoji-panel {
      position: absolute;
      bottom: 56px;
      left: 0;
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(20px);
      border: 1px solid rgba(255, 255, 255, 0.8);
      border-radius: 12px;
      padding: 10px;
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
      width: 240px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
    }
    .emoji-btn {
      cursor: pointer;
      padding: 8px;
      font-size: 20px;
      border-radius: 8px;
      transition: all 0.2s ease;
      background: transparent;
    }
    .emoji-btn:hover {
      background: rgba(102, 126, 234, 0.15);
      transform: scale(1.2);
    }

    #messages {
      text-align: center;
      color: #dc2626;
      margin-top: 10px;
      min-height: 20px;
      font-weight: 600;
    }

    /* PREMIUM SOUND TOGGLE */
    .sound-toggle {
      position: absolute;
      top: 30px;
      right: 30px;
      left: auto;
      width: 44px;
      height: 44px;
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(20px);
      border-radius: 50%;
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 22px;
      cursor: pointer;
      z-index: 100000;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      border: 2px solid rgba(102, 126, 234, 0.3);
    }
    .sound-toggle:hover {
      transform: scale(1.15) rotate(10deg);
      box-shadow: 0 10px 30px rgba(102, 126, 234, 0.4);
      border-color: #667eea;
    }
    .sound-toggle.muted {
      opacity: 0.6;
      background: rgba(220, 38, 38, 0.1);
    }

    .btn-primary {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
    }

    /* SIDEBAR (Desktop Fixed Width) */
    .sidebar {
      display: flex;
      gap: 20px;
      width: 750px; /* Fixed width to prevent resizing */
      flex-shrink: 0;
      margin-top: 3%;
    }

    /* ========================================
       MOBILE RESPONSIVE ENHANCEMENTS
       ======================================== */
    @media (max-width: 900px) {
      body {
        padding: 10px;
        align-items: flex-start;
      }

      .container {
        padding: 8px;
        max-height: none;
        width: 100%;
        border-radius: 20px;
      }

      h1 {
        font-size: 24px;
        margin-bottom: 6px;
      }

      .subtitle {
        font-size: 11px;
        margin-bottom: 10px;
      }

      /* Hide Room Info on Mobile to make space for Chat */
      .game-info {
        display: none !important;
      }

      .game-layout {
        flex-direction: column !important;
        gap: 14px !important;
      }

      .sidebar {
        width: 100% !important;
        flex-direction: column !important;
        gap: 12px !important;
      }
      
      /* === HIDE MOVE HISTORY ON MOBILE === */
      .move-history {
        display: none !important;
      }

      /* Reduce Chat Height on Mobile */
      .chat-messages {
        height: 110px !important;
      }

      /* Expand Chat Input on Mobile */
      .chat-input input {
        max-width: none !important;
        min-width: 0 !important;
      }
      .chat-input > div {
        width: 100%;
      }

      /* === FIX TIMER OVERLAP AND BOARD SPACING === */
      .board-section {
        width: 100%;
        max-width: 100%;
        /* Adjusted margin top to keep things tight but safe */
        margin-top: 10px !important; 
        margin-bottom: 20px;
      }

      .chessboard {
        width: 100%;
        max-width: 100%;
        border: 4px solid rgba(44, 62, 80, 0.8);
      }
      
      /* Force timers to left side on mobile and CLOSER to board */
      #blackTimer {
        top: -32px !important;       /* Reduced distance (was -50px) */
        left: 0 !important;          /* Align to LEFT edge */
        transform: none !important;  
        font-size: 13px !important;
        padding: 6px 12px !important;
      }

      #whiteTimer {
        bottom: -32px !important;    /* Reduced distance (was -50px) */
        left: 0 !important;          
        transform: none !important;  
        font-size: 13px !important;
        padding: 6px 12px !important;
      }

      #blackName {
        top: -80px !important;
        right: auto !important;
        left: 50% !important;
        transform: translateX(-50%) !important;
        font-size: 14px !important;
        padding: 8px 20px !important;
      }

      #whiteName {
        bottom: -80px !important;
        right: auto !important;
        left: 50% !important;
        transform: translateX(-50%) !important;
        font-size: 14px !important;
        padding: 8px 20px !important;
      }

      .board-wrapper {
        margin-top: 85px !important;
        margin-bottom: 95px !important;
      }

      .button-group {
        display: grid !important;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
        margin-top: 14px;
      }
      
      .button-group button {
        width: 100%;
        padding: 12px 10px;
        font-size: 13px;
      }
    }

    /* CUSTOM SCROLLBAR */
    ::-webkit-scrollbar {
      width: 8px;
      height: 8px;
    }
    ::-webkit-scrollbar-track {
      background: rgba(0, 0, 0, 0.05);
      border-radius: 10px;
    }
    ::-webkit-scrollbar-thumb {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      border-radius: 10px;
    }
    ::-webkit-scrollbar-thumb:hover {
      background: linear-gradient(135deg, #764ba2 0%, #667eea 100%);
    }

    #visitorCounter {
        position: fixed;
        bottom: 20px;
        right: 20px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 12px 20px;
        border-radius: 25px;
        box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        font-size: 14px;
        font-weight: 600;
        display: flex;
        align-items: center;
        gap: 8px;
        z-index: 99999;
        animation: slideInCounter 0.5s ease-out;
    }

    @keyframes slideInCounter {
        from {
            transform: translateX(100px);
            opacity: 0;
        }
        to {
            transform: translateX(0);
            opacity: 1;
        }
    }

    #visitorCounter:hover {
        transform: scale(1.05);
        transition: transform 0.3s ease;
    }

    @media (max-width: 768px) {
        #visitorCounter {
            bottom: 10px;
            right: 10px;
            padding: 8px 15px;
            font-size: 12px;
        }
    }
  </style>
</head>

<body>

<div class="container">
    <div id="soundToggle" class="sound-toggle" onclick="toggleSound()" title="Toggle Sound">üîä</div>

    <h1>‚ôî Chess Master ‚ôö</h1>
    <p class="subtitle">‚ö° Premium Edition ‚Äî Real-time Multiplayer</p>
    
    <div id="loadingMessage" style="text-align:center; padding:40px; font-weight:bold; color:#333;">
        <div style="font-size:24px; margin-bottom:10px;">üîå</div>
        Connecting to server...
    </div>

    <div id="game" style="display:none;">
      <div class="game-info">
        <h3>üë• Room: <span id="roomName"></span></h3>
      </div>

      <div class="game-layout" style="display:flex; gap:40px; align-items:flex-start;">
        <div class="board-section">
          
          <div class="turn-indicator" id="turnIndicator"></div>

          <div class="board-wrapper" id="boardWrapper">
            <!-- === FIXED: ADDED PLAYER NAME ELEMENTS === -->
            <div id="blackTimer" class="timer black" style="left:0px;">5:00</div>
            <div id="whiteTimer" class="timer white" style="left:0px;">5:00</div>
            <div id="blackName" class="player-name black">Black</div>
            <div id="whiteName" class="player-name white">White</div>
            <!-- ========================================= -->
            <div class="chessboard" id="chessboard"></div>
            <div id="disconnectOverlay" class="disconnect-overlay">
                <div class="waiting-spinner"></div>
                <div style="font-size:18px; margin-bottom:8px;">‚ö†Ô∏è Opponent Disconnected</div>
                <div style="font-size:14px; font-weight:normal;">Claiming win in <span id="disconnectTimer">15</span>s...</div>
            </div>
          </div>

          <div class="status" id="status"></div>
          <div class="messages" id="messages"></div>
        </div>

        <div class="sidebar">

          <div class="move-history" style="flex:1;">
            <h4>üìú Move History</h4>
            <div class="move-list" id="moveList"></div>
          </div>

          <div class="chat-box" id="chatBox" style="flex:1;">
            <h4>üí¨ Live Chat</h4>
            <div class="chat-messages" id="chatMessages" style="height:570px;"></div>
            <div class="typing-indicator" id="typingIndicator"></div>

            <div class="chat-input" style="margin-top:10px; position:relative;">
              <div style="display:flex;align-items:center;gap:8px;">
                
                <div id="emojiPickerWrap" style="position:relative;">
                  <button id="emojiToggle" class="emoji-btn" title="Add Emoji" style="background:transparent;padding:6px;">üòä</button>

                  <div id="emojiPanel" class="emoji-panel" style="display:none;">
                    <div class="emoji-btn" onclick="insertEmoji('üòÄ')">üòÄ</div>
                    <div class="emoji-btn" onclick="insertEmoji('üòÑ')">üòÑ</div>
                    <div class="emoji-btn" onclick="insertEmoji('üòÇ')">üòÇ</div>
                    <div class="emoji-btn" onclick="insertEmoji('üòç')">üòç</div>
                    <div class="emoji-btn" onclick="insertEmoji('üëç')">üëç</div>
                    <div class="emoji-btn" onclick="insertEmoji('ü§ù')">ü§ù</div>
                    <div class="emoji-btn" onclick="insertEmoji('üéâ')">üéâ</div>
                    <div class="emoji-btn" onclick="insertEmoji('üòÖ')">üòÖ</div>
                    <div class="emoji-btn" onclick="insertEmoji('‚ôüÔ∏è')">‚ôüÔ∏è</div>
                    <div class="emoji-btn" onclick="insertEmoji('‚ù§Ô∏è')">‚ù§Ô∏è</div>
                    <div class="emoji-btn" onclick="insertEmoji('üî•')">üî•</div>
                    <div class="emoji-btn" onclick="insertEmoji('‚ö°')">‚ö°</div>
                  </div>
                </div>

                <input id="chatInput" type="text" placeholder="Type your message..." />
                <button onclick="sendChat()">Send</button>
              </div>
            </div>
          </div>

        </div>
      </div>

      <div class="button-group">
        <button onclick="goHome()">üè† Home</button>
        <button onclick="offerDraw()" class="btn-draw">ü§ù Offer Draw</button>
        <button onclick="resignGame()" class="btn-danger">üè≥Ô∏è Resign</button>
      </div>

    </div>
</div>

<div class="promotion-modal" id="promotionModal" aria-hidden="true">
  <div class="promotion-content">
    <h3>üëë Promote Your Pawn</h3>
    <p style="color:#666;margin-top:8px;">Choose a piece:</p>
    <div class="promotion-pieces" id="promotionPieces"></div>
    <div style="margin-top:16px;">
      <button onclick="cancelPromotion()" class="btn-secondary">Cancel</button>
    </div>
  </div>
</div>

<div class="draw-modal" id="drawModal" aria-hidden="true">
  <div class="draw-content">
    <h3>ü§ù Draw Offer</h3>
    <p id="drawMessage" style="color:#666;margin-top:12px;font-size:15px;"></p>
    <div style="margin-top:16px;display:flex;gap:12px;justify-content:center;">
      <button onclick="respondToDraw(true)" class="btn-bot">‚úÖ Accept</button>
      <button onclick="respondToDraw(false)" class="btn-danger">‚ùå Decline</button>
    </div>
  </div>
</div>

<script>
const socket = io({ 
  transports: ["websocket", "polling"],
  reconnection: true,
  reconnectionDelay: 500,
  reconnectionAttempts: 10
});

// --- URL PARAMS ---
const params = new URLSearchParams(window.location.search);
const URL_ROOM = params.get('room');
const URL_NAME = params.get('name');
const URL_MODE = params.get('mode');
const URL_TIME = params.get('time');

if (!URL_ROOM || !URL_NAME) {
    alert("Invalid game parameters. Redirecting to home.");
    window.location.href = "/";
}

let currentRoom = URL_ROOM;
let playerColor = null;
let playerName = URL_NAME;
let gameState = null;
let selectedSquare = null;
let possibleMoves = [];
let pendingPromotion = null;
let moveHistory = [];
let soundEnabled = true;
let lastMoveWasMine = false;
let lastMoveTime = 0;
let whiteSeconds = 0;
let blackSeconds = 0;
let timerInterval = null;
let pendingMoves = new Map();
let moveSequence = 0;
let disconnectInterval = null; // New variable for local countdown
let isDragging = false;
let pendingUpdate = null;

/* -------------------------
   TIMER POSITIONING FIX
   ------------------------- */
function updateTimerPositions(myColor) {
    const whiteTimer = document.getElementById("whiteTimer");
    const blackTimer = document.getElementById("blackTimer");
    const whiteName = document.getElementById("whiteName");
    const blackName = document.getElementById("blackName");

    // Reset styles first to avoid conflicts
    whiteTimer.style.top = "";
    whiteTimer.style.bottom = "";
    blackTimer.style.top = "";
    blackTimer.style.bottom = "";

    if (whiteName) { whiteName.style.top = ""; whiteName.style.bottom = ""; }
    if (blackName) { blackName.style.top = ""; blackName.style.bottom = ""; }

    if (myColor === 'black') {
        // I am Black (Bottom). White is Opponent (Top).
        whiteTimer.style.top = "-60px";
        whiteTimer.style.bottom = "auto";
        
        blackTimer.style.bottom = "-60px";
        blackTimer.style.top = "auto";

        if (whiteName) whiteName.style.top = "-60px";
        if (blackName) blackName.style.bottom = "-60px";
    } else {
        // I am White (Bottom). Black is Opponent (Top). (Default)
        whiteTimer.style.bottom = "-60px";
        whiteTimer.style.top = "auto";
        
        blackTimer.style.top = "-60px";
        blackTimer.style.bottom = "auto";

        if (whiteName) whiteName.style.bottom = "-60px";
        if (blackName) blackName.style.top = "-60px";
    }
}

/* -------------------------
   HELPER FUNCTIONS
   ------------------------- */
function timeStringToSeconds(str) {
  if (!str || typeof str !== "string" || !str.includes(":")) return 0;
  const [m, s] = str.split(":").map(Number);
  return m * 60 + s;
}

function formatSeconds(sec) {
  sec = Math.max(0, Math.floor(sec));
  const m = Math.floor(sec / 60);
  const s = sec % 60;
  return `${m}:${s.toString().padStart(2, "0")}`;
}

function updateDisplayedTimers() {
  const whiteTimer = document.getElementById("whiteTimer");
  const blackTimer = document.getElementById("blackTimer");
  
  if (whiteTimer) whiteTimer.textContent = formatSeconds(whiteSeconds);
  if (blackTimer) blackTimer.textContent = formatSeconds(blackSeconds);
  
  if (gameState && !gameState.winner) {
    const activeColor = gameState.turn;
    if (whiteTimer) whiteTimer.classList.toggle("active", activeColor === "white");
    if (blackTimer) blackTimer.classList.toggle("active", activeColor === "black");
  } else {
    if (whiteTimer) whiteTimer.classList.remove("active");
    if (blackTimer) blackTimer.classList.remove("active");
  }
}

function startLocalTimer() {
  if (timerInterval) clearInterval(timerInterval);

  timerInterval = setInterval(() => {
    if (!gameState || gameState.winner || (gameState.isActive === false)) {
      clearInterval(timerInterval);
      return;
    }
    if (gameState.turn === "white" && whiteSeconds > 0) {
      whiteSeconds = Math.max(0, whiteSeconds - 1);
    } else if (gameState.turn === "black" && blackSeconds > 0) {
      blackSeconds = Math.max(0, blackSeconds - 1);
    }
    updateDisplayedTimers();
    if (whiteSeconds === 0 || blackSeconds === 0) {
      clearInterval(timerInterval);
    }
  }, 1000);
}

const sounds = {
  move: { freq: 400, duration: 0.1 },
  capture: { freq: 300, duration: 0.15 },
  check: { freq: 600, duration: 0.2 },
  win: { freq: 800, duration: 0.3 },
  notify: { freq: 500, duration: 0.1 }
};

let audioCtx = null;

function initAudio() {
  // Guard against environments where AudioContext is not supported
  if (typeof window.AudioContext === 'undefined' && typeof window.webkitAudioContext === 'undefined') return;
  if (!audioCtx) {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  }
  // Browsers require user interaction to start/resume audio.
  if (audioCtx.state === 'suspended') {
    audioCtx.resume();
  }
}

function playSound(type) {
  if (!soundEnabled) return;
  try {
    initAudio(); // Ensure the single audio context is active
    if (!audioCtx) return; // Exit if audio context is not available
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.connect(gain); 
    gain.connect(audioCtx.destination);
    osc.frequency.value = sounds[type].freq;
    gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + sounds[type].duration);
    osc.start(audioCtx.currentTime);
    osc.stop(audioCtx.currentTime + sounds[type].duration);
  } catch (e) { console.error("Sound playback failed:", e); }
}

function toggleSound(){
  soundEnabled = !soundEnabled;
  const btn = document.getElementById("soundToggle");
  if (btn) {
    btn.textContent = soundEnabled ? "üîä" : "üîá";
    btn.classList.toggle("muted", !soundEnabled);
  }
}

function animateMove(from, to, renderFn) {
  const fromSq = document.querySelector(`.square[data-row="${from.row}"][data-col="${from.col}"]`);
  const toSq = document.querySelector(`.square[data-row="${to.row}"][data-col="${to.col}"]`);
  
  const piece = fromSq ? fromSq.querySelector('.piece') : null;
  const captured = toSq ? toSq.querySelector('.piece') : null;
  
  const startRect = piece ? piece.getBoundingClientRect() : null;
  const capturedRect = captured ? captured.getBoundingClientRect() : null;

  renderFn();

  // Animate Capture
  if (capturedRect) {
    const ghost = captured.cloneNode(true);
    ghost.style.position = 'fixed';
    ghost.style.left = `${capturedRect.left}px`;
    ghost.style.top = `${capturedRect.top}px`;
    ghost.style.width = `${capturedRect.width}px`;
    ghost.style.height = `${capturedRect.height}px`;
    ghost.style.zIndex = '90';
    ghost.style.pointerEvents = 'none';
    ghost.style.transition = 'all 0.3s ease-out';
    ghost.style.opacity = '1';
    ghost.style.transform = 'scale(1)';
    
    document.body.appendChild(ghost);
    
    requestAnimationFrame(() => {
      ghost.style.opacity = '0';
      ghost.style.transform = 'scale(0.8)';
    });
    
    setTimeout(() => ghost.remove(), 300);
  }

  if (startRect) {
    const newToSq = document.querySelector(`.square[data-row="${to.row}"][data-col="${to.col}"]`);
    const newPiece = newToSq ? newToSq.querySelector('.piece') : null;
    
    if (newPiece) {
      const endRect = newPiece.getBoundingClientRect();
      const dx = startRect.left - endRect.left;
      const dy = startRect.top - endRect.top;
      
      if (Math.abs(dx) < 1 && Math.abs(dy) < 1) return;

      newPiece.style.transition = 'none';
      newPiece.style.transform = `translate(${dx}px, ${dy}px)`;
      newPiece.style.zIndex = '100';
      
      // Force reflow
      void newPiece.offsetWidth;
      
      newPiece.style.transition = 'transform 0.25s cubic-bezier(0.2, 0.8, 0.2, 1)';
      newPiece.style.transform = 'translate(0, 0)';
      
      setTimeout(() => {
        newPiece.style.zIndex = '';
        newPiece.style.transition = '';
        newPiece.style.transform = '';
      }, 260);
    }
  }
}

function applyOptimisticMove(from, to, promotion = null) {
  if (!gameState) return null;
  const optimisticState = JSON.parse(JSON.stringify(gameState));
  const piece = optimisticState.board[from.row][from.col];
  optimisticState.board[to.row][to.col] = piece;
  optimisticState.board[from.row][from.col] = ".";
  if (promotion) {
    const promotedPiece = playerColor === "white" ? promotion.toUpperCase() : promotion.toLowerCase();
    optimisticState.board[to.row][to.col] = promotedPiece;
  }
  optimisticState.turn = optimisticState.turn === "white" ? "black" : "white";
  return optimisticState;
}

function revertOptimisticMove(moveId) {
  if (pendingMoves.has(moveId)) {
    const moveData = pendingMoves.get(moveId);
    if (moveData.previousState) {
      gameState = moveData.previousState;
      renderBoard(gameState);
      updateStatus(gameState);
      updateTurnIndicator(gameState);
    }
    pendingMoves.delete(moveId);
  }
}

// Chat Functions
function sendChat(){
  const input = document.getElementById("chatInput");
  const text = input ? input.value.trim() : "";
  if(!text || !currentRoom) return;
  socket.emit("send_message", {
    room: currentRoom,
    sender: playerColor || "spectator",
    message: text,
    senderName: playerName
  });
  input.value = "";
  stopTypingNow();
  hideEmojiPanel();
}

function appendChat(data, isLocal){
  const box = document.getElementById("chatMessages");
  if (!box) return;
  const div = document.createElement("div");
  div.className = "chat-line " + (isLocal ? "you" : "opponent");
  let displayName = data.senderName;
  if (!displayName) {
    if (data.sender === "white") displayName = "‚ôî White";
    else if (data.sender === "black") displayName = "‚ôö Black";
    else displayName = "User";
  }
  const prefix = data.sender === "white" ? "‚ôî" : 
                 data.sender === "black" ? "‚ôö" : "üí¨";
  div.innerText = `${prefix} ${displayName}: ${data.message}`;
  box.appendChild(div);
  box.scrollTop = box.scrollHeight;
}

let typingTimeout = null;
let isTyping = false;

function handleTypingInput(){
  if(!currentRoom || !playerColor) return;
  if(!isTyping){
    isTyping = true;
    socket.emit("typing", { room: currentRoom, sender: playerColor, senderName: playerName });
  }
  if(typingTimeout) clearTimeout(typingTimeout);
  typingTimeout = setTimeout(() => { stopTypingNow(); }, 1400);
}

function stopTypingNow(){
  if(!isTyping) return;
  isTyping = false;
  if (currentRoom && playerColor) {
    socket.emit("stop_typing", { room: currentRoom, sender: playerColor, senderName: playerName });
  }
}

function insertEmoji(emoji) {
  const input = document.getElementById("chatInput");
  if (!input) return;
  const start = input.selectionStart;
  const end = input.selectionEnd;
  const text = input.value;
  input.value = text.slice(0, start) + emoji + text.slice(end);
  input.selectionStart = input.selectionEnd = start + emoji.length;
  input.focus();
  handleTypingInput();
}

function hideEmojiPanel(){
  const panel = document.getElementById("emojiPanel");
  if(panel) panel.style.display = "none";
}

function initializeEmojiPanel() {
  const emojiToggle = document.getElementById("emojiToggle");
  const emojiPanel = document.getElementById("emojiPanel");
  const emojiWrap = document.getElementById("emojiPickerWrap");
  if (emojiToggle && emojiPanel) {
    emojiToggle.addEventListener("click", (e) => {
      e.stopPropagation();
      const visible = window.getComputedStyle(emojiPanel).display !== "none";
      emojiPanel.style.display = visible ? "none" : "flex";
    });
    emojiPanel.addEventListener("click", (e) => { e.stopPropagation(); });
  }
  document.addEventListener("click", (e) => {
    if (emojiWrap && !emojiWrap.contains(e.target)) {
      hideEmojiPanel();
    }
  });
}

// === FIXED: UPDATE PLAYER NAMES FUNCTION ===
function updatePlayerNames(state) {
  const whiteNameEl = document.getElementById("whiteName");
  const blackNameEl = document.getElementById("blackName");

  if (!whiteNameEl || !blackNameEl || !state) return;

  let whiteName = "";
  let blackName = "";

  // In multiplayer, use player names directly
  if (playerColor === "white") {
    whiteName = playerName;
    blackName = state.opponentName || "Opponent";
  } else if (playerColor === "black") {
    blackName = playerName;
    whiteName = state.opponentName || "Opponent";
  } else {
    // Spectator fallback
    whiteName = state.whiteName || "White";
    blackName = state.blackName || "Black";
  }

  whiteNameEl.textContent = whiteName;
  blackNameEl.textContent = blackName;
}


/* -------------------------
   SOCKET EVENTS
   ------------------------- */
socket.on("connect",()=>{
  // Do NOT hide loading message yet. Wait for room_created/room_joined.
  
  if (URL_MODE === 'create') {
    socket.emit("create_room", { room: URL_ROOM, timeControl: URL_TIME, playerName: URL_NAME, bot: false });
  } else if (URL_MODE === 'join') {
    socket.emit("join_room", { room: URL_ROOM, playerName: URL_NAME });
  } else if (URL_MODE === 'bot') {
    socket.emit("create_room", { room: URL_ROOM, timeControl: URL_TIME, playerName: URL_NAME, bot: true });
  }
});

socket.on("disconnect",()=>{
  // Optional: Show disconnect UI
});

// --- SUCCESS HANDLERS (Reveal UI) ---
socket.on("room_created", startGame);
socket.on("room_joined", startGame);

// --- ERROR HANDLER (Redirect) ---
socket.on("error", (data) => {
    alert(data.message);
    window.location.href = "/";
});

function startGame(data){
  document.getElementById("loadingMessage").style.display = "none";
  document.getElementById("game").style.display = "block";

  currentRoom = data.room;
  playerColor = data.color;
  gameState = data.state;

  // === FIX: UPDATE TIMER POSITIONS ===
  updateTimerPositions(playerColor);
  
  // === FIX: UPDATE PLAYER NAMES ===
  updatePlayerNames(gameState);

  const roomName = document.getElementById("roomName");
  const playerColorBadge = document.getElementById("playerColorBadge");
  
  if (roomName) roomName.textContent = currentRoom;
  if (playerColorBadge) {
    const colorLabel = playerColor === "white" ? "‚ôî WHITE" : "‚ôö BLACK";
    const displayName = playerName || "Player";
    playerColorBadge.innerHTML =
      `<span class="player-badge ${playerColor}">
         ${colorLabel} ‚Äî ${displayName}
       </span>`;
  }

  const defaultSeconds = URL_TIME || 300;
  whiteSeconds = gameState.whiteTimeFormatted ? timeStringToSeconds(gameState.whiteTimeFormatted) : defaultSeconds;
  blackSeconds = gameState.blackTimeFormatted ? timeStringToSeconds(gameState.blackTimeFormatted) : defaultSeconds;

  updateDisplayedTimers();

  const isWaiting = (gameState.isActive === false);
  updateWaitingOverlay(isWaiting);

  if (!isWaiting) {
      startLocalTimer();
  }

  renderBoard(gameState);
  updateStatus(gameState);
  updateTurnIndicator(gameState);
}

socket.on("game_start", d=>{
  gameState = d.state;
  updateWaitingOverlay(false);
  
  // === FIX: UPDATE PLAYER NAMES ON GAME START ===
  updatePlayerNames(gameState);
  
  startLocalTimer();
  renderBoard(gameState);
  updateStatus(gameState);
  updateTurnIndicator(gameState);
  playSound("notify");
});

function updateWaitingOverlay(show) {
    const wrapper = document.getElementById("boardWrapper");
    let overlay = document.getElementById("waitingOverlay");
    if (show) {
        if (!overlay) {
            overlay = document.createElement("div");
            overlay.id = "waitingOverlay";
            overlay.className = "waiting-overlay";
            overlay.innerHTML = `
                <div class="waiting-spinner"></div>
                <div>Waiting for opponent to join...</div>
                <div style="font-size:0.8em; margin-top:5px; color:#ddd;">Share Room Name: ${currentRoom}</div>
            `;
            wrapper.appendChild(overlay);
        }
    } else {
        if (overlay) overlay.remove();
    }
}

/* =======================================
   NEW: DISCONNECT / RECONNECT HANDLERS
   ======================================= */
socket.on("player_disconnected", (data) => {
    // Only show if the disconnected player is NOT me
    if (data.color !== playerColor) {
        const overlay = document.getElementById("disconnectOverlay");
        const timerSpan = document.getElementById("disconnectTimer");
        let timeLeft = data.timeout || 15;
        
        if (overlay && timerSpan) {
            overlay.classList.add("active");
            timerSpan.textContent = timeLeft;
            
            if (disconnectInterval) clearInterval(disconnectInterval);
            disconnectInterval = setInterval(() => {
                timeLeft--;
                timerSpan.textContent = timeLeft;
                if (timeLeft <= 0) {
                    clearInterval(disconnectInterval);
                }
            }, 1000);
        }
    }
});

socket.on("player_reconnected", (data) => {
    // Hide overlay if opponent comes back
    const overlay = document.getElementById("disconnectOverlay");
    if (overlay) overlay.classList.remove("active");
    if (disconnectInterval) clearInterval(disconnectInterval);
});

socket.on("game_update", d => {
  if (isDragging) {
    pendingUpdate = d;
    return;
  }
  const now = Date.now();
  // If this update confirms my own move and arrived too quickly (before animation finished),
  // delay it slightly to prevent the board re-render from cutting off the animation.
  if (d.lastMove && lastMoveWasMine && (now - lastMoveTime < 260)) {
    setTimeout(() => processGameUpdate(d), 260 - (now - lastMoveTime));
    return;
  }
  processGameUpdate(d);
});

function processGameUpdate(d) {
  const prev = gameState;
  const isMyMoveConfirmation = d.lastMove && lastMoveWasMine;
  
  const performUpdate = () => {
    const boardChanged = JSON.stringify(prev.board) !== JSON.stringify(d.state.board);
    gameState = d.state;

    // === FIX: UPDATE PLAYER NAMES ON EVERY UPDATE ===
    updatePlayerNames(gameState);

    pendingMoves.clear();
    const SERVER_SYNC_THRESHOLD = 2;
    if (gameState.whiteTimeFormatted !== undefined) {
      const srv = timeStringToSeconds(gameState.whiteTimeFormatted);
      if (srv > 0 && Math.abs(srv - whiteSeconds) > SERVER_SYNC_THRESHOLD) {
        whiteSeconds = srv;
      }
    }
    if (gameState.blackTimeFormatted !== undefined) {
      const srv = timeStringToSeconds(gameState.blackTimeFormatted);
      if (srv > 0 && Math.abs(srv - blackSeconds) > SERVER_SYNC_THRESHOLD) {
        blackSeconds = srv;
      }
    }

    updateDisplayedTimers();
    
    // Clear disconnect overlay if game ends
    if (gameState.winner) {
        const overlay = document.getElementById("disconnectOverlay");
        if (overlay) overlay.classList.remove("active");
        if (disconnectInterval) clearInterval(disconnectInterval);
    }

    if (boardChanged || !isMyMoveConfirmation) {
      if (d.lastMove) addMoveToHistory(d.lastMove, d.moveNotation);
      renderBoard(gameState, d.lastMove);
    } else {
      if (d.lastMove) addMoveToHistory(d.lastMove, d.moveNotation);
    }
    updateStatus(gameState);
    updateTurnIndicator(gameState);
  };

  if (d.lastMove && !isMyMoveConfirmation) {
    animateMove(d.lastMove.from, d.lastMove.to, performUpdate);
  } else {
    performUpdate();
  }

  if (prev) {
    if (isMyMoveConfirmation) {
      lastMoveWasMine = false;
    }

    if (gameState.winner) playSound("win");
    else if (gameState.check) playSound("check");
    else if (d.lastMove && !isMyMoveConfirmation) {
      const tr = d.lastMove.to.row;
      const tc = d.lastMove.to.col;
      const wasCapture = prev.board[tr][tc] !== ".";
      playSound(wasCapture ? "capture" : "move");
    }
  }
}

socket.on("user_stop_typing", data=>{
  if(data.sender===playerColor) return;
  const dest = document.getElementById("typingIndicator");
  if (dest) dest.innerText = "";
});
socket.on("chat_message", data => {
  appendChat(data, data.sender === playerColor);
  if (data.sender !== playerColor) playSound("notify");
});
// socket.on("possible_moves", ...) REMOVED for Speed
socket.on("invalid_move", data => {
  lastMoveWasMine = false;
  console.warn("Server rejected move:", data);
  if (data.moveId) revertOptimisticMove(data.moveId);
  const messages = document.getElementById("messages");
  if (messages) messages.textContent = "‚ùå Invalid move!";
});

/* -------------------------
   INITIALIZATION
   ------------------------- */
document.addEventListener("DOMContentLoaded", function() {
  initializeEmojiPanel();
  const chatInputEl = document.getElementById("chatInput");
  if (chatInputEl) {
    chatInputEl.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        e.preventDefault();
        sendChat();
      }
    });
    chatInputEl.addEventListener("input", handleTypingInput);
  }
  // Initialize audio context on the first user interaction anywhere on the page
  document.body.addEventListener('click', initAudio, { once: true });
});

/* -------------------------
   BOARD RENDERING
   ------------------------- */
function renderBoard(state, lastMove=null){
  const board=document.getElementById("chessboard");
  if (!board) return;
  board.innerHTML="";
  const flipped = (playerColor === "black");
  const rows = flipped ? [...Array(8).keys()].reverse() : [...Array(8).keys()];
  const cols = flipped ? [...Array(8).keys()].reverse() : [...Array(8).keys()];
  for (let r of rows){
    for (let c of cols){
      const sq=document.createElement("div");
      sq.className=`square ${(r+c)%2===0?"light":"dark"}`;
      sq.dataset.row=r;
      sq.dataset.col=c;

      // === NEW: IN-BOARD COORDINATES ===
      const isBottom = (playerColor === "black") ? (r === 0) : (r === 7);
      const isLeft = (playerColor === "black") ? (c === 7) : (c === 0);

      if (isBottom) {
          const fileLabel = document.createElement("div");
          fileLabel.className = "square-coord file";
          fileLabel.textContent = String.fromCharCode(97 + c);
          sq.appendChild(fileLabel);
      }
      if (isLeft) {
          const rankLabel = document.createElement("div");
          rankLabel.className = "square-coord rank";
          rankLabel.textContent = (8 - r).toString();
          sq.appendChild(rankLabel);
      }
      // =================================

      if(lastMove){
        const fm=lastMove.from, to=lastMove.to;
        if((fm.row===r && fm.col===c)||(to.row===r && to.col===c)){
          sq.classList.add("last-move");
        }
      }
      if(selectedSquare && selectedSquare.row===r && selectedSquare.col===c){
        sq.classList.add("selected");
      }
      if(possibleMoves.some(m=>m.row===r && m.col===c)){
        sq.classList.add("possible-move");
      }
      const piece = state.board[r][c];
      if(piece !== "."){
        const pDiv=document.createElement("div");
        pDiv.className="piece";
        const isWhitePiece = piece === piece.toUpperCase();
        const color = isWhitePiece ? "white" : "black";
        if(color === state.turn && color === playerColor){
          pDiv.draggable=true;
        }
        pDiv.dataset.row=r;
        pDiv.dataset.col=c;
        
        // === UPDATED DRAG HANDLER FOR DRAG & DROP FIX ===
        pDiv.addEventListener("dragstart", e=>{
          isDragging = true;
          selectedSquare = { row:r, col:c };
          
          // Get PRE-LOADED MOVES from state
          const key = `${r},${c}`;
          possibleMoves = (state.moves && state.moves[key]) ? state.moves[key] : [];

          // FIX: Do NOT call renderBoard() here. It destroys the DOM element being dragged.
          // Instead, manually toggle classes to show highlights.
          
          // 1. Clear old highlights
          document.querySelectorAll('.square').forEach(s => {
             s.classList.remove('selected', 'possible-move');
          });

          // 2. Highlight Source
          const sourceSq = document.querySelector(`.square[data-row="${r}"][data-col="${c}"]`);
          if(sourceSq) sourceSq.classList.add('selected');

          // 3. Highlight Targets
          possibleMoves.forEach(m => {
             const targetSq = document.querySelector(`.square[data-row="${m.row}"][data-col="${m.col}"]`);
             if(targetSq) targetSq.classList.add('possible-move');
          });
          
          e.dataTransfer.setData("fromRow", r);
          e.dataTransfer.setData("fromCol", c);
        });

        // Add dragend to clean up highlights if drag is cancelled
        pDiv.addEventListener("dragend", () => {
             isDragging = false;
             if (pendingUpdate) {
               processGameUpdate(pendingUpdate);
               pendingUpdate = null;
             } else {
               renderBoard(gameState, lastMove);
             }
        });

        const img=document.createElement("img");
        const clr = isWhitePiece ? "w" : "b";
        const type = piece.toLowerCase();
        img.src=`https://images.chesscomfiles.com/chess-themes/pieces/neo/150/${clr}${type}.png`;
        pDiv.appendChild(img);
        sq.appendChild(pDiv);
      }
      sq.addEventListener("click", ()=> handleSquareClick(r,c,state));
      sq.addEventListener("dragover", e=> e.preventDefault());
      sq.addEventListener("drop", e=>{
        e.preventDefault();
        const fr=parseInt(e.dataTransfer.getData("fromRow"));
        const fc=parseInt(e.dataTransfer.getData("fromCol"));
        const from={row:fr,col:fc};
        const to={row:r,col:c};
        const valid = possibleMoves.some(m=>m.row===r && m.col===c);
        if(!valid){
          const messages = document.getElementById("messages");
          if (messages) messages.textContent="‚ùå Invalid move!";
          return;
        }
        const movingPiece = state.board[fr][fc];
        const isPawn = movingPiece.toLowerCase()==="p";
        const isPromoRank = (playerColor==="white" && r===0) ||
                            (playerColor==="black" && r===7);
        if(isPawn && isPromoRank){
          pendingPromotion = { from, to };
          showPromotionModal(playerColor);
        } else {
          makeMove(from,to,null,true);
        }
      });
      board.appendChild(sq);
    }
  }
}

function handleSquareClick(row, col, state){
  if(state.winner) return;
  if (state.isActive === false) {
    const messages = document.getElementById("messages");
    if (messages) messages.textContent = "‚è≥ Waiting for opponent...";
    return;
  }
  if(state.turn !== playerColor){
    const messages = document.getElementById("messages");
    if (messages) messages.textContent = "‚è≥ Wait for your turn!";
    return;
  }
  const piece = state.board[row][col];
  const isWhite = piece !== "." && piece === piece.toUpperCase();
  const isMine = piece !== "." && (
    (playerColor==="white" && isWhite) ||
    (playerColor==="black" && !isWhite)
  );
  
  // === UPDATED LOGIC: USE PRE-CALCULATED MOVES ===
  if(isMine){
    selectedSquare = { row,col };
    // Get moves directly from state instead of socket
    const key = `${row},${col}`;
    possibleMoves = (state.moves && state.moves[key]) ? state.moves[key] : [];
    
    // Re-render to show highlights immediately
    renderBoard(state);
    
    const messages = document.getElementById("messages");
    if (messages) messages.textContent="";
    return;
  }
  // ==============================================

  if(!selectedSquare) return;
  const isValid = possibleMoves.some(m=>m.row===row && m.col===col);
  if(!isValid){
    const messages = document.getElementById("messages");
    if (messages) messages.textContent = "‚ùå Invalid move!";
    return;
  }
  const movingPiece = state.board[selectedSquare.row][selectedSquare.col];
  const isPawn = movingPiece.toLowerCase()==="p";
  const isPromoRank = (playerColor==="white" && row===0) ||
                      (playerColor==="black" && row===7);
  if(isPawn && isPromoRank){
    pendingPromotion = { from:selectedSquare, to:{row,col} };
    showPromotionModal(playerColor);
  } else {
    makeMove(selectedSquare, {row,col}, null);
  }
}

function makeMove(from, to, promotion=null, isDrop=false){
  lastMoveWasMine = true;
  lastMoveTime = Date.now();
  const moveId = ++moveSequence;
  const previousState = JSON.parse(JSON.stringify(gameState));
  
  const performMove = () => {
    const optimisticState = applyOptimisticMove(from, to, promotion);
    if (optimisticState) {
      gameState = optimisticState;
      renderBoard(gameState, { from, to });
      updateTurnIndicator(gameState);
      const wasCapture = previousState.board[to.row][to.col] !== ".";
      playSound(wasCapture ? "capture" : "move");
      pendingMoves.set(moveId, {
        from, to, promotion, previousState, timestamp: Date.now()
      });
    }
  };

  if (!isDrop) {
    animateMove(from, to, performMove);
  } else {
    performMove();
  }

  socket.emit("move", { room: currentRoom, from, to, promotion, moveId });
  selectedSquare = null;
  possibleMoves = [];
  pendingPromotion = null;
  const messages = document.getElementById("messages");
  if (messages) messages.textContent = "";
}

function showPromotionModal(color){
  const modal=document.getElementById("promotionModal");
  const pcs=document.getElementById("promotionPieces");
  if (!modal || !pcs) return;
  pcs.innerHTML="";
  const opt=['q','r','b','n'];
  const pre = (color==="white") ? "w" : "b";
  opt.forEach(t=>{
    const img=document.createElement("img");
    img.src=`https://images.chesscomfiles.com/chess-themes/pieces/neo/150/${pre}${t}.png`;
    img.onclick = ()=>{
      makeMove(pendingPromotion.from, pendingPromotion.to, t);
      modal.classList.remove("active");
    };
    pcs.appendChild(img);
  });
  modal.classList.add("active");
}
function cancelPromotion(){
  pendingPromotion=null;
  const modal = document.getElementById("promotionModal");
  if (modal) modal.classList.remove("active");
}
function addMoveToHistory(lastMove,notation){
  moveHistory.push({ from:lastMove.from, to:lastMove.to, notation: notation });
  renderMoveHistory();
}
function renderMoveHistory(){
  const list=document.getElementById("moveList");
  if (!list) return;
  list.innerHTML="";
  for(let i=0;i<moveHistory.length;i+=2){
    const num=document.createElement("div");
    num.className="move-number";
    num.textContent=(i/2+1)+".";
    list.appendChild(num);
    const w=document.createElement("div");
    w.className="move-item white";
    w.textContent=moveHistory[i].notation;
    list.appendChild(w);
    if(i+1 < moveHistory.length){
      const b=document.createElement("div");
      b.className="move-item black";
      b.textContent=moveHistory[i+1].notation;
      list.appendChild(b);
    } else {
      list.appendChild(document.createElement("div"));
    }
  }
  const parent = list.parentElement;
  if (parent) parent.scrollTop = parent.scrollHeight;
}

function updateTurnIndicator(state){
  const ind=document.getElementById("turnIndicator");
  if (!ind) return;
  if(state.winner){
    ind.textContent="üèÅ Game Over";
    ind.style.background="linear-gradient(135deg, #11998e 0%, #38ef7d 100%)";
    ind.style.color="#fff";
    return;
  }
  ind.textContent = (state.turn==="white") ? "‚ôî White to move" : "‚ôö Black to move";
  ind.style.background = "";
  ind.style.color = "";
}
function updateStatus(state){
  const s=document.getElementById("status");
  if (!s) return;
  if(state.winner){
    if(state.winner==="draw"){
      s.textContent="ü§ù Game Draw!";
      s.style.background="linear-gradient(135deg, #f7971e 0%, #ffd200 100%)";
      s.style.color="#fff";
    } else {
      const w = state.winner==="white" ? "‚ôî WHITE" : "‚ôö BLACK";
      const r =
        state.reason==="checkmate" ? "by Checkmate" :
        state.reason==="resign" ? "by Resignation" :
        state.reason==="timeout" ? "by Timeout" : 
        state.reason==="abandonment" ? "by Abandonment" : ""; // Add abandonment case
      s.textContent=`üëë ${w} Wins ${r}!`;
      s.style.background="linear-gradient(135deg, #11998e 0%, #38ef7d 100%)";
      s.style.color="#fff";
    }
    return;
  }
  if(state.check){
    const t = state.turn==="white"?"‚ôî WHITE":"‚ôö BLACK";
    s.textContent=`‚ö†Ô∏è CHECK! ${t}'s turn`;
    s.style.background="linear-gradient(135deg, #eb3349 0%, #f45c43 100%)";
    s.style.color="#fff";
    return;
  }
  s.textContent="";
  s.style.background="";
  s.style.color="";
}

function goHome(){
  if(confirm("Return to home? Current game will end.")){
    socket.emit("leave_room",{room:currentRoom});
    window.location.href = "/";
  }
}
function offerDraw(){
  socket.emit("offer_draw",{room:currentRoom,color:playerColor});
  const messages = document.getElementById("messages");
  if (messages) messages.textContent="ü§ù Draw offer sent...";
}
socket.on("draw_offered", data=>{
  const drawMessage = document.getElementById("drawMessage");
  const drawModal = document.getElementById("drawModal");
  if (drawMessage && drawModal) {
    drawMessage.textContent = `${data.fromColor.toUpperCase()} offers a draw. Accept?`;
    drawModal.classList.add("active");
  }
});
socket.on("draw_declined", ()=>{
  const messages = document.getElementById("messages");
  if (messages) messages.textContent="‚ùå Opponent declined your draw.";
});
function respondToDraw(acc){
  const drawModal = document.getElementById("drawModal");
  if (drawModal) drawModal.classList.remove("active");
  socket.emit("respond_draw",{room:currentRoom,accept:acc});
}
function resetGame(){
  socket.emit("reset_game",{room:currentRoom});
  moveHistory=[];
  renderMoveHistory();
  pendingMoves.clear();
}
function resignGame(){
  if(confirm("Are you sure you want to resign?")){
    socket.emit("resign",{room:currentRoom,color:playerColor});
  }
}
</script>
</body>
</html>
