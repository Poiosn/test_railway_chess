<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Chess Master ‚Äî Premium Edition</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
  <style>
    /* static/style.css content embedded */
    * { margin:0; padding:0; box-sizing:border-box; }

    /* STATIC LIGHT SKY BLUE BACKGROUND */
    body {
      font-family:'Inter','Segoe UI','Helvetica Neue',sans-serif;
      background: #87CEEB;
      min-height:100vh;
      display:flex;
      justify-content:center;
      align-items:center;
      padding:20px;
      position:relative;
      overflow-x:hidden;
    }

    /* GLASSMORPHISM CONTAINER */
    .container{
      background: rgba(255, 255, 255, 0.25);
      backdrop-filter: blur(20px) saturate(180%);
      -webkit-backdrop-filter: blur(20px) saturate(180%);
      border: 1px solid rgba(255, 255, 255, 0.3);
      border-radius: 32px;
      box-shadow: 
        0 8px 32px 0 rgba(31, 38, 135, 0.37),
        inset 0 1px 0 0 rgba(255, 255, 255, 0.5);
      padding:28px;
      width:90vw;
      max-width:1500px;
      height:auto;
      max-height:92vh;
      position:relative;
      z-index:1;
      overflow-y:auto;
      animation: containerFadeIn 0.6s ease;
    }

    @keyframes containerFadeIn {
      from { opacity: 0; transform: translateY(20px); }
      to { opacity: 1; transform: translateY(0); }
    }

    h1 {
      text-align:center;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 50%, #f093fb 100%);
      background-size: 200% auto;
      -webkit-background-clip:text;
      -webkit-text-fill-color:transparent;
      background-clip:text;
      font-size:36px;
      font-weight:900;
      margin-bottom:8px;
      letter-spacing:-1.5px;
      animation: titleShine 3s linear infinite;
      text-shadow: 0 0 30px rgba(102, 126, 234, 0.3);
    }
    @keyframes titleShine { to { background-position: 200% center; } }

    .subtitle { text-align:center; color:#555; margin-bottom:14px; font-size:13px; font-weight:500; letter-spacing: 0.5px; }

    .game-info {
      text-align:center; margin-bottom: 60px; padding:16px;
      background: rgba(255, 255, 255, 0.6); backdrop-filter: blur(10px);
      border-radius:16px; border: 1px solid rgba(255, 255, 255, 0.8);
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.1); transition: transform 0.3s ease;
    }
    .game-info:hover { transform: translateY(-2px); box-shadow: 0 12px 30px rgba(0, 0, 0, 0.15); }
    .game-info h3 { font-size: 18px; font-weight: 800; color: #333; margin-bottom: 8px; }

    .player-badge {
      padding: 6px 16px; border-radius: 20px; font-weight: 800; font-size: 14px; display: inline-block;
      transition: all 0.3s ease; box-shadow: 0 4px 10px rgba(0, 0, 0, 0.15);
    }
    .player-badge.white { background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%); border: 2px solid #e0e0e0; color: #333; }
    .player-badge.black { background: linear-gradient(135deg, #434343 0%, #000000 100%); color: #fff; border: 2px solid #666; }

    input[type="text"] {
      flex:1; max-width:320px; min-width:200px; padding:14px 20px;
      border: 2px solid rgba(102, 126, 234, 0.3); border-radius:14px; font-size:15px;
      transition: all 0.3s ease; background: rgba(255, 255, 255, 0.9); backdrop-filter: blur(10px);
    }
    input[type="text"]:focus { outline: none; border-color: #667eea; transform: translateY(-2px); }

    button {
      padding: 14px 24px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white; border: none; border-radius: 14px; cursor: pointer; font-weight: 700;
      font-size: 15px; transition: all 0.3s; box-shadow: 0 6px 20px rgba(102, 126, 234, 0.3);
      position: relative; overflow: hidden;
    }
    button:hover { transform: translateY(-3px); box-shadow: 0 10px 30px rgba(102, 126, 234, 0.4); }
    button:active { transform: translateY(-1px); }
    .btn-bot { background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%); }
    .btn-secondary { background: linear-gradient(135deg, #bdc3c7 0%, #2c3e50 100%); }
    .btn-danger { background: linear-gradient(135deg, #eb3349 0%, #f45c43 100%); }
    .btn-draw { background: linear-gradient(135deg, #f7971e 0%, #ffd200 100%); }

    .timer {
      padding: 8px 16px; border-radius: 12px; text-align: center; font-size: 16px;
      font-weight: 800; transition: all 0.3s ease; position: absolute;
      backdrop-filter: blur(10px); box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
      min-width: 80px; z-index: 50;
    }
    .timer.white { background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%); border: 2px solid #e0e0e0; color: #333; }
    .timer.black { background: linear-gradient(135deg, #434343 0%, #000000 100%); color: #fff; border: 2px solid #666; }
    .timer.active { transform: scale(1.08); animation: timerPulse 1.5s ease-in-out infinite; }
    @keyframes timerPulse { 0%, 100% { transform: scale(1.08); } 50% { transform: scale(1.12); } }

    .board-section { position: relative; width: 100%; max-width: 700px; margin: 0 auto; display: flex; flex-direction: column; align-items: center; }
    
    .chessboard {
      display: grid; grid-template-columns: repeat(8, 1fr); width: min(92vw, 700px); aspect-ratio: 1 / 1;
      border: 6px solid rgba(44, 62, 80, 0.8); border-radius: 12px; overflow: hidden;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4); position: relative; transform-style: preserve-3d;
    }

    .waiting-overlay {
      position: absolute; top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.6); backdrop-filter: blur(5px); z-index: 100;
      display: flex; flex-direction: column; align-items: center; justify-content: center;
      border-radius: 12px; color: white; font-weight: bold; animation: fadeIn 0.3s;
    }
    
    .disconnect-overlay {
      position: absolute; top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(220, 38, 38, 0.8); backdrop-filter: blur(5px); z-index: 101;
      display: none; flex-direction: column; align-items: center; justify-content: center;
      border-radius: 12px; color: white; font-weight: bold; animation: fadeIn 0.3s; text-align: center; padding: 20px;
    }
    .disconnect-overlay.active { display: flex; }
    
    .waiting-spinner {
      border: 4px solid rgba(255,255,255,0.3); border-top: 4px solid #fff; border-radius: 50%;
      width: 40px; height: 40px; animation: spin 1s linear infinite; margin-bottom: 15px;
    }
    @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    @keyframes fadeIn { from { opacity:0; } to { opacity:1; } }

    .coordinates {
      position: absolute; font-size: 12px; font-weight: 800; color: #2c3e50; pointer-events: none;
      text-shadow: 0 1px 2px rgba(255, 255, 255, 0.8);
    }
    .coord-file { bottom: -28px; left: 0; width: 100%; display: flex; justify-content: space-between; padding: 0 8px; }
    .coord-rank { top: 0; height: 100%; left: -32px; display: flex; flex-direction: column; justify-content: space-between; }
    .coord-file.flipped { top: -24px; bottom: auto; }
    .coord-rank.flipped { left: auto; right: -28px; }

    .square {
      aspect-ratio: 1; display: flex; align-items: center; justify-content: center;
      cursor: pointer; position: relative; overflow: hidden;
    }
    .square.light { background: linear-gradient(135deg, #f5e6d3 0%, #f0d9b5 100%); }
    .square.dark { background: linear-gradient(135deg, #c9a882 0%, #b58863 100%); }
    .square.selected {
      background: radial-gradient(circle, #baca44 0%, #a8b834 100%) !important;
      box-shadow: inset 0 0 30px rgba(0, 0, 0, 0.4);
    }
    .square.last-move { background: radial-gradient(circle, #ffd93d 0%, #cdd26a 100%) !important; }
    
    .square.possible-move::after {
      content: ''; position: absolute; width: 35%; height: 35%;
      background: radial-gradient(circle, rgba(34, 197, 94, 0.6), rgba(34, 197, 94, 0.3));
      border-radius: 50%;
    }

    .piece {
      width: 100%; height: 100%; display: flex; align-items: center; justify-content: center;
      cursor: grab;
    }
    .piece:active { cursor: grabbing; }
    .piece img { width: 88%; height: 88%; object-fit: contain; pointer-events: none; filter: drop-shadow(0 2px 8px rgba(0, 0, 0, 0.3)); }

    .move-history {
      background: rgba(255, 255, 255, 0.6); backdrop-filter: blur(10px); border-radius: 16px;
      padding: 14px; height: 600px; overflow-y: auto; border: 1px solid rgba(255, 255, 255, 0.8);
    }
    .move-history h4 {
      color: #2c3e50; margin-bottom: 12px; font-size: 15px; font-weight: 800; position: sticky; top: 0;
      background: rgba(255, 255, 255, 0.95); padding: 10px 8px; border-radius: 8px; z-index: 10;
    }
    .move-list { display: grid; grid-template-columns: 45px 1fr 1fr; gap: 10px; font-size: 14px; margin-top: 10px; }
    .move-number { color: #666; font-weight: 800; text-align: right; padding-right: 10px; }
    .move-item {
      background: rgba(248, 249, 250, 0.8); padding: 6px 10px; border-radius: 8px;
      cursor: pointer; text-align: center; overflow: hidden;
    }
    .move-item.white { border-left: 3px solid #e0e0e0; }
    .move-item.black { border-left: 3px solid #333; }

    .turn-indicator {
      text-align: center; padding: 8px; border-radius: 14px; font-size: 15px; font-weight: 800;
      margin-bottom: 6px; background: rgba(255, 255, 255, 0.6); backdrop-filter: blur(10px);
    }
    .status {
      min-height: 30px; text-align: center; padding: 12px; margin-top: 14px;
      border-radius: 14px; font-size: 16px; font-weight: 800; backdrop-filter: blur(10px);
    }
    .button-group { display: flex; justify-content: center; gap: 14px; margin-top: 20px; flex-wrap: wrap; }
    
    .promotion-modal, .draw-modal {
      position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; display: none;
      align-items: center; justify-content: center; background: rgba(0, 0, 0, 0.7); backdrop-filter: blur(8px); z-index: 9999;
    }
    .promotion-modal.active, .draw-modal.active { display: flex; }
    .promotion-content, .draw-content {
      background: rgba(255, 255, 255, 0.95); padding: 28px; border-radius: 20px;
      text-align: center; min-width: 320px; box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4);
    }
    .promotion-pieces img { width: 75px; height: 75px; margin: 10px; cursor: pointer; }

    .chat-box {
      background: rgba(255, 255, 255, 0.6); backdrop-filter: blur(10px); border-radius: 16px;
      padding: 12px; flex: 1;
    }
    .chat-messages { height: 220px; overflow-y: auto; padding: 8px; display: flex; flex-direction: column; gap: 8px; }
    .chat-line { padding: 10px 12px; border-radius: 12px; max-width: 85%; word-break: break-word; font-size: 13px; font-weight: 500; }
    .chat-line.you { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; align-self: flex-end; }
    .chat-line.opponent { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; align-self: flex-start; }
    .chat-input { display: flex; gap: 8px; margin-top: 10px; align-items: center; }
    .chat-input input { flex: 1; padding: 12px; border-radius: 12px; border: 2px solid rgba(102, 126, 234, 0.3); }
    .emoji-panel {
      position: absolute; bottom: 56px; left: 0; background: rgba(255, 255, 255, 0.95);
      border-radius: 12px; padding: 10px; display: flex; gap: 6px; flex-wrap: wrap; width: 240px;
    }
    .emoji-btn { cursor: pointer; padding: 8px; font-size: 20px; border-radius: 8px; background: transparent; }

    #messages { text-align: center; color: #dc2626; margin-top: 10px; min-height: 20px; font-weight: 600; }
    .sound-toggle {
      position: fixed; top: 20px; left: 20px; width: 44px; height: 44px;
      background: rgba(255, 255, 255, 0.95); border-radius: 50%; display: flex; align-items: center;
      justify-content: center; font-size: 22px; cursor: pointer; z-index: 100000;
      border: 2px solid rgba(102, 126, 234, 0.3);
    }

    @media (max-width: 900px) {
      .game-layout { flex-direction: column !important; gap: 14px !important; }
      .sidebar { width: 100% !important; flex-direction: column !important; }
      .move-history { display: none !important; }
      .chat-box { width: 100%; height: 350px !important; }
      #blackTimer { top: -10px !important; left: 50% !important; transform: translateX(-50%); }
      #whiteTimer { bottom: -10px !important; left: 50% !important; transform: translateX(-50%); }
      .coord-file { bottom: -22px !important; font-size: 10px !important; }
      .coord-rank { left: -24px !important; font-size: 10px !important; }
    }
  </style>
</head>

<body>
<div id="soundToggle" class="sound-toggle" onclick="toggleSound()" title="Toggle Sound">üîä</div>

<div class="container">
    <h1>‚ôî Chess Master ‚ôö</h1>
    <p class="subtitle">‚ö° Premium Edition ‚Äî Real-time Multiplayer</p>
    
    <div id="loadingMessage" style="text-align:center; padding:40px; font-weight:bold; color:#333;">
        <div style="font-size:24px; margin-bottom:10px;">üîå</div> Connecting to server...
    </div>

    <div id="game" style="display:none;">
      <div class="game-info">
        <h3>üë• Room: <span id="roomName"></span></h3>
        <p>You are playing as: <span id="playerColorBadge"></span></p>
      </div>

      <div class="game-layout" style="display:flex; gap:40px; align-items:flex-start;">
        <div class="board-section">
          <div id="blackTimer" class="timer black" style="left:0px;">5:00</div>
          <div id="whiteTimer" class="timer white" style="left:0px;">5:00</div>
          <div class="turn-indicator" id="turnIndicator"></div>
          <div class="board-wrapper" style="position:relative;" id="boardWrapper">
            <div class="chessboard" id="chessboard"></div>
            <div class="coordinates coord-file" id="coordFiles"></div>
            <div class="coordinates coord-rank" id="coordRanks"></div>
            <div id="disconnectOverlay" class="disconnect-overlay">
                <div class="waiting-spinner"></div>
                <div>‚ö†Ô∏è Opponent Disconnected</div>
                <div style="font-size:14px; font-weight:normal;">Win in <span id="disconnectTimer">15</span>s...</div>
            </div>
          </div>
          <div class="status" id="status"></div>
          <div class="messages" id="messages"></div>
        </div>
        
        <div class="sidebar" style="display:flex; gap:20px;">
          <div class="move-history" style="flex:1;">
            <h4>üìú Move History</h4>
            <div class="move-list" id="moveList"></div>
          </div>
          <div class="chat-box" id="chatBox">
            <h4>üí¨ Live Chat</h4>
            <div class="chat-messages" id="chatMessages"></div>
            <div class="typing-indicator" id="typingIndicator"></div>
            <div class="chat-input" style="margin-top:10px; position:relative;">
              <div style="display:flex;align-items:center;gap:8px; width:100%;">
                <div id="emojiPickerWrap" style="position:relative;">
                  <button id="emojiToggle" class="emoji-btn" style="background:transparent;padding:6px;">üòä</button>
                  <div id="emojiPanel" class="emoji-panel" style="display:none;">
                    <div class="emoji-btn" onclick="insertEmoji('üòÄ')">üòÄ</div>
                    <div class="emoji-btn" onclick="insertEmoji('üòÑ')">üòÑ</div>
                    <div class="emoji-btn" onclick="insertEmoji('üòÇ')">üòÇ</div>
                    <div class="emoji-btn" onclick="insertEmoji('üëç')">üëç</div>
                    <div class="emoji-btn" onclick="insertEmoji('ü§ù')">ü§ù</div>
                    <div class="emoji-btn" onclick="insertEmoji('üî•')">üî•</div>
                  </div>
                </div>
                <input id="chatInput" type="text" placeholder="Type your message..." />
                <button onclick="sendChat()">Send</button>
              </div>
            </div>
          </div>
        </div>
      </div>

      <div class="button-group">
        <button onclick="goHome()">üè† Home</button>
        <button onclick="offerDraw()" class="btn-draw">ü§ù Offer Draw</button>
        <button onclick="resignGame()" class="btn-danger">üè≥Ô∏è Resign</button>
      </div>
    </div>
</div>

<div class="promotion-modal" id="promotionModal" aria-hidden="true">
  <div class="promotion-content">
    <h3>üëë Promote Your Pawn</h3>
    <div class="promotion-pieces" id="promotionPieces"></div>
    <div style="margin-top:16px;">
      <button onclick="cancelPromotion()" class="btn-secondary">Cancel</button>
    </div>
  </div>
</div>

<div class="draw-modal" id="drawModal" aria-hidden="true">
  <div class="draw-content">
    <h3>ü§ù Draw Offer</h3>
    <p id="drawMessage" style="color:#666;margin-top:12px;font-size:15px;"></p>
    <div style="margin-top:16px;display:flex;gap:12px;justify-content:center;">
      <button onclick="respondToDraw(true)" class="btn-bot">‚úÖ Accept</button>
      <button onclick="respondToDraw(false)" class="btn-danger">‚ùå Decline</button>
    </div>
  </div>
</div>

<script>
const socket = io({ 
  transports: ["websocket", "polling"],
  reconnection: true,
  reconnectionDelay: 500,
  reconnectionAttempts: 10
});

const params = new URLSearchParams(window.location.search);
const URL_ROOM = params.get('room');
const URL_NAME = params.get('name');
const URL_MODE = params.get('mode');
const URL_TIME = params.get('time');

if (!URL_ROOM || !URL_NAME) { alert("Invalid parameters. Redirecting."); window.location.href = "/"; }

let currentRoom = URL_ROOM;
let playerColor = null;
let playerName = URL_NAME;
let gameState = null;
// --- CRITICAL FIX VARIABLES ---
let lastValidServerState = null; // Stores the authoritative state from server
let isOptimisticUpdate = false;  // True when we are showing a move that hasn't been confirmed yet
// ------------------------------
let selectedSquare = null;
let possibleMoves = [];
let pendingPromotion = null;
let moveHistory = [];
let soundEnabled = true;
let lastMoveWasMine = false;
let whiteSeconds = 0;
let blackSeconds = 0;
let timerInterval = null;
let moveSequence = 0;
let disconnectInterval = null;

// ... (Helper functions remain mostly same, logic changed in Socket events)

function formatSeconds(sec) {
  sec = Math.max(0, Math.floor(sec));
  const m = Math.floor(sec / 60);
  const s = sec % 60;
  return `${m}:${s.toString().padStart(2, "0")}`;
}

function updateDisplayedTimers() {
  const wt = document.getElementById("whiteTimer");
  const bt = document.getElementById("blackTimer");
  if (wt) wt.textContent = formatSeconds(whiteSeconds);
  if (bt) bt.textContent = formatSeconds(blackSeconds);
  if (gameState && !gameState.winner) {
    if (wt) wt.classList.toggle("active", gameState.turn === "white");
    if (bt) bt.classList.toggle("active", gameState.turn === "black");
  } else {
    if (wt) wt.classList.remove("active");
    if (bt) bt.classList.remove("active");
  }
}

function startLocalTimer() {
  if (timerInterval) clearInterval(timerInterval);
  let lastTick = performance.now();
  timerInterval = setInterval(() => {
    if (!gameState || gameState.winner || (gameState.isActive === false)) { clearInterval(timerInterval); return; }
    const now = performance.now();
    const delta = (now - lastTick) / 1000; 
    lastTick = now;
    if (gameState.turn === "white") whiteSeconds = Math.max(0, whiteSeconds - delta);
    else if (gameState.turn === "black") blackSeconds = Math.max(0, blackSeconds - delta);
    updateDisplayedTimers();
  }, 100);
}

function playSound(type) {
  if (!soundEnabled) return;
  try {
    const audio = new (window.AudioContext || window.webkitAudioContext)();
    const osc = audio.createOscillator();
    const gain = audio.createGain();
    osc.connect(gain); gain.connect(audio.destination);
    const sounds = { move: 400, capture: 300, check: 600, win: 800, notify: 500 };
    osc.frequency.value = sounds[type] || 400;
    gain.gain.setValueAtTime(0.3, audio.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.01, audio.currentTime + 0.15);
    osc.start(audio.currentTime); osc.stop(audio.currentTime + 0.15);
  } catch (e) {}
}

function toggleSound(){
  soundEnabled = !soundEnabled;
  document.getElementById("soundToggle").textContent = soundEnabled ? "üîä" : "üîá";
}

function applyOptimisticMove(from, to, promotion = null) {
  if (!gameState) return null;
  const optimisticState = JSON.parse(JSON.stringify(gameState));
  const piece = optimisticState.board[from.row][from.col];
  optimisticState.board[to.row][to.col] = piece;
  optimisticState.board[from.row][from.col] = ".";
  if (promotion) {
    const promotedPiece = playerColor === "white" ? promotion.toUpperCase() : promotion.toLowerCase();
    optimisticState.board[to.row][to.col] = promotedPiece;
  }
  optimisticState.turn = optimisticState.turn === "white" ? "black" : "white";
  return optimisticState;
}

// CHAT
function sendChat(){
  const input = document.getElementById("chatInput");
  const text = input ? input.value.trim() : "";
  if(!text || !currentRoom) return;
  socket.emit("send_message", { room: currentRoom, sender: playerColor || "spectator", message: text, senderName: playerName });
  input.value = "";
}
socket.on("chat_message", data => {
  const box = document.getElementById("chatMessages");
  const div = document.createElement("div");
  div.className = "chat-line " + (data.sender === playerColor ? "you" : "opponent");
  div.innerText = `${data.senderName || data.sender}: ${data.message}`;
  box.appendChild(div);
  box.scrollTop = box.scrollHeight;
  if(data.sender !== playerColor) playSound("notify");
});
function insertEmoji(e) {
  const i = document.getElementById("chatInput");
  i.value += e; i.focus();
}
document.getElementById("emojiToggle").onclick = (e) => {
    e.stopPropagation();
    const p = document.getElementById("emojiPanel");
    p.style.display = p.style.display==="none"?"flex":"none";
};
document.onclick = (e) => {
    if(!document.getElementById("emojiPickerWrap").contains(e.target)) document.getElementById("emojiPanel").style.display="none";
};

// --- CORE SOCKET LOGIC ---

socket.on("connect",()=>{
  if (URL_MODE === 'create') socket.emit("create_room", { room: URL_ROOM, timeControl: URL_TIME, playerName: URL_NAME, bot: false });
  else if (URL_MODE === 'join') socket.emit("join_room", { room: URL_ROOM, playerName: URL_NAME });
  else if (URL_MODE === 'bot') socket.emit("create_room", { room: URL_ROOM, timeControl: URL_TIME, playerName: URL_NAME, bot: true });
});

socket.on("room_created", startGame);
socket.on("room_joined", startGame);
socket.on("game_start", d => {
    startGame({room: currentRoom, color: playerColor, state: d.state});
    playSound("notify");
});

function startGame(data){
  document.getElementById("loadingMessage").style.display = "none";
  document.getElementById("game").style.display = "block";
  currentRoom = data.room;
  if(data.color) playerColor = data.color; // Keep color if reconnecting
  
  gameState = data.state;
  lastValidServerState = JSON.parse(JSON.stringify(data.state)); // Initialize valid state
  isOptimisticUpdate = false;

  document.getElementById("roomName").textContent = currentRoom;
  document.getElementById("playerColorBadge").innerHTML = `<span class="player-badge ${playerColor}">${playerColor.toUpperCase()} ‚Äî ${playerName}</span>`;
  
  whiteSeconds = gameState.whiteTime;
  blackSeconds = gameState.blackTime;
  updateDisplayedTimers();
  updateWaitingOverlay(gameState.isActive === false);
  if(gameState.isActive) startLocalTimer();
  
  renderBoard(gameState);
  updateStatus(gameState);
  updateTurnIndicator(gameState);
}

socket.on("game_update", d => {
  // CRITICAL FIX: RECONCILIATION LOGIC
  
  // 1. Always update the authoritative state
  lastValidServerState = JSON.parse(JSON.stringify(d.state));

  // 2. If we are waiting for a move (Optimistic), check if this update confirms it
  if (isOptimisticUpdate) {
      const myOptimisticBoard = JSON.stringify(gameState.board);
      const serverBoard = JSON.stringify(d.state.board);
      
      if (myOptimisticBoard === serverBoard) {
          // Success! Server matches our prediction.
          isOptimisticUpdate = false;
          gameState = d.state;
      } else {
          // Mismatch. 
          // Case A: The server sent a heartbeat with the OLD state (turn hasn't flipped yet).
          // We MUST ignore this to prevent the piece snapping back.
          // Case B: The server sent a totally new state (opponent moved?).
          
          if (d.state.turn === playerColor) {
             // Server says it's still my turn, but I thought I moved.
             // This is likely just a heartbeat delay.
             // DO NOT OVERWRITE BOARD. Just update time.
             if (d.state.whiteTime) whiteSeconds = d.state.whiteTime;
             if (d.state.blackTime) blackSeconds = d.state.blackTime;
             return; // EXIT FUNCTION EARLY
          } else {
             // The turn changed to something else? Accept server truth.
             isOptimisticUpdate = false;
             gameState = d.state;
          }
      }
  } else {
      // Normal update (opponent moved, or heartbeat)
      const prev = gameState;
      gameState = d.state;
      if (prev && prev.board && JSON.stringify(prev.board) !== JSON.stringify(gameState.board)) {
         playSound("move");
      }
  }

  // Update Timers & UI
  whiteSeconds = gameState.whiteTime;
  blackSeconds = gameState.blackTime;
  updateDisplayedTimers();
  
  if (d.lastMove) addMoveToHistory(d.lastMove, d.moveNotation);
  renderBoard(gameState, d.lastMove);
  updateStatus(gameState);
  updateTurnIndicator(gameState);
  
  if (gameState.winner) {
     document.getElementById("disconnectOverlay").classList.remove("active");
     playSound("win");
  } else if (gameState.check) {
     playSound("check");
  }
});

socket.on("invalid_move", () => {
  console.warn("‚ùå Move rejected by server. Rolling back.");
  
  // 1. Hard reset to the last authoritative state from server
  if (lastValidServerState) {
      gameState = JSON.parse(JSON.stringify(lastValidServerState));
  }
  
  // 2. Reset flags
  isOptimisticUpdate = false;
  
  // 3. Force Render
  renderBoard(gameState);
  updateTurnIndicator(gameState);
  
  // 4. Show Error
  const msg = document.getElementById("messages");
  if(msg) {
      msg.textContent = "‚ùå Invalid move!";
      setTimeout(()=> msg.textContent="", 2000);
  }
});

socket.on("possible_moves", d => { possibleMoves = d.moves; renderBoard(gameState); });

// ... (Rest of UI functions: renderBoard, updateStatus, etc.)

function renderBoard(state, lastMove=null){
  const board=document.getElementById("chessboard");
  board.innerHTML="";
  const flipped = (playerColor === "black");
  const rows = flipped ? [...Array(8).keys()].reverse() : [...Array(8).keys()];
  const cols = flipped ? [...Array(8).keys()].reverse() : [...Array(8).keys()];
  
  for (let r of rows){
    for (let c of cols){
      const sq=document.createElement("div");
      sq.className=`square ${(r+c)%2===0?"light":"dark"}`;
      sq.dataset.row=r; sq.dataset.col=c;
      
      if(lastMove && ((lastMove.from.row===r && lastMove.from.col===c)||(lastMove.to.row===r && lastMove.to.col===c))) sq.classList.add("last-move");
      if(selectedSquare && selectedSquare.row===r && selectedSquare.col===c) sq.classList.add("selected");
      if(possibleMoves.some(m=>m.row===r && m.col===c)) sq.classList.add("possible-move");

      const piece = state.board[r][c];
      if(piece !== "."){
        const pDiv=document.createElement("div");
        pDiv.className="piece";
        const isWhite = piece === piece.toUpperCase();
        if((isWhite?"white":"black") === state.turn && (isWhite?"white":"black") === playerColor) pDiv.draggable=true;
        
        pDiv.addEventListener("dragstart", e=>{
          selectedSquare = { row:r, col:c };
          socket.emit("get_possible_moves", { room:currentRoom, from:selectedSquare });
          e.dataTransfer.setData("fromRow", r); e.dataTransfer.setData("fromCol", c);
        });
        
        const img=document.createElement("img");
        img.src=`https://images.chesscomfiles.com/chess-themes/pieces/neo/150/${isWhite?"w":"b"}${piece.toLowerCase()}.png`;
        pDiv.appendChild(img);
        sq.appendChild(pDiv);
      }
      
      sq.onclick = () => handleSquareClick(r,c,state);
      sq.ondragover = e => e.preventDefault();
      sq.ondrop = e => {
        e.preventDefault();
        const fr=parseInt(e.dataTransfer.getData("fromRow"));
        const fc=parseInt(e.dataTransfer.getData("fromCol"));
        
        // Prevent capturing own pieces (Quick Check)
        const target = state.board[r][c];
        const isMine = target !== "." && ((playerColor==="white" && target===target.toUpperCase()) || (playerColor==="black" && target!==target.toUpperCase()));
        if (isMine) return;

        attemptMove({row:fr,col:fc}, {row:r,col:c}, state);
      };
      
      board.appendChild(sq);
    }
  }
  
  // Coords
  document.getElementById("coordFiles").innerHTML = (flipped?["h","g","f","e","d","c","b","a"]:["a","b","c","d","e","f","g","h"]).map(x=>`<span>${x}</span>`).join("");
  document.getElementById("coordRanks").innerHTML = (flipped?["1","2","3","4","5","6","7","8"]:["8","7","6","5","4","3","2","1"]).map(x=>`<span>${x}</span>`).join("");
}

function handleSquareClick(row, col, state){
  if(state.winner || !state.isActive) return;
  if(state.turn !== playerColor && !isOptimisticUpdate) return; // Block clicks if turn isn't ours (unless correcting)

  const piece = state.board[row][col];
  const isWhite = piece !== "." && piece === piece.toUpperCase();
  const isMine = piece !== "." && ((playerColor==="white" && isWhite) || (playerColor==="black" && !isWhite));

  if(isMine){
    selectedSquare = { row,col };
    socket.emit("get_possible_moves",{ room:currentRoom, from:selectedSquare });
    renderBoard(state); // Re-render to show selection
    return;
  }

  if(selectedSquare){
    attemptMove(selectedSquare, {row,col}, state);
  }
}

function attemptMove(from, to, state) {
    const movingPiece = state.board[from.row][from.col];
    const isPawn = movingPiece.toLowerCase()==="p";
    const isPromo = (playerColor==="white" && to.row===0) || (playerColor==="black" && to.row===7);
    
    if(isPawn && isPromo){
        pendingPromotion = { from, to };
        const modal=document.getElementById("promotionModal");
        const pcs=document.getElementById("promotionPieces");
        pcs.innerHTML="";
        ['q','r','b','n'].forEach(t=>{
            const img=document.createElement("img");
            img.src=`https://images.chesscomfiles.com/chess-themes/pieces/neo/150/${playerColor==="white"?"w":"b"}${t}.png`;
            img.onclick = ()=>{ makeMove(from, to, t); modal.classList.remove("active"); };
            pcs.appendChild(img);
        });
        modal.classList.add("active");
    } else {
        makeMove(from, to, null);
    }
}

function makeMove(from, to, promotion){
    lastMoveWasMine = true;
    const moveId = ++moveSequence;

    // 1. Optimistic Update
    const nextState = applyOptimisticMove(from, to, promotion);
    gameState = nextState;
    isOptimisticUpdate = true; // LOCK UPDATES UNTIL CONFIRMED OR REJECTED
    
    // 2. Render immediately
    renderBoard(gameState, {from,to});
    updateTurnIndicator(gameState);
    playSound("move");
    selectedSquare = null;
    possibleMoves = [];

    // 3. Send to server
    socket.emit("move", { room: currentRoom, from, to, promotion, moveId });
}

function updateTurnIndicator(state){
  const el = document.getElementById("turnIndicator");
  if(state.winner) { el.textContent="üèÅ Game Over"; return; }
  el.textContent = (state.turn==="white") ? "‚ôî White to move" : "‚ôö Black to move";
}

function updateWaitingOverlay(show) {
    const d = document.getElementById("disconnectOverlay");
    if(show) {
        if(!document.getElementById("waitingOverlay")){
             const ov = document.createElement("div"); ov.id="waitingOverlay"; ov.className="waiting-overlay";
             ov.innerHTML=`<div class="waiting-spinner"></div><div>Waiting for opponent...</div>`;
             document.getElementById("boardWrapper").appendChild(ov);
        }
    } else {
        const ov = document.getElementById("waitingOverlay");
        if(ov) ov.remove();
    }
}

function updateStatus(state){
    const s = document.getElementById("status");
    if(state.winner){
        s.textContent = state.winner==="draw" ? "ü§ù Draw!" : `üëë ${state.winner.toUpperCase()} Wins!`;
        s.style.background = "#11998e"; s.style.color="white";
    } else if (state.check) {
        s.textContent = "‚ö†Ô∏è CHECK!"; s.style.background = "#eb3349"; s.style.color="white";
    } else {
        s.textContent=""; s.style.background="";
    }
}

function cancelPromotion(){ document.getElementById("promotionModal").classList.remove("active"); pendingPromotion=null; }
function addMoveToHistory(m,n){ 
    moveHistory.push({notation:n}); 
    const list=document.getElementById("moveList"); list.innerHTML="";
    for(let i=0;i<moveHistory.length;i+=2){
        list.innerHTML += `<div class="move-number">${(i/2+1)}.</div><div class="move-item white">${moveHistory[i].notation}</div>${moveHistory[i+1]?`<div class="move-item black">${moveHistory[i+1].notation}</div>`:''}`;
    }
}
function goHome(){ if(confirm("Quit game?")) { socket.emit("leave_room",{room:currentRoom}); window.location.href="/"; } }
function offerDraw(){ socket.emit("offer_draw",{room:currentRoom,color:playerColor}); }
function resignGame(){ if(confirm("Resign?")) socket.emit("resign",{room:currentRoom,color:playerColor}); }
function respondToDraw(acc){ socket.emit("respond_draw",{room:currentRoom,accept:acc}); document.getElementById("drawModal").classList.remove("active"); }

socket.on("draw_offered", d=>{ document.getElementById("drawMessage").textContent=`${d.fromColor} offers draw.`; document.getElementById("drawModal").classList.add("active"); });
socket.on("player_disconnected", ()=>{ document.getElementById("disconnectOverlay").classList.add("active"); });
socket.on("player_reconnected", ()=>{ document.getElementById("disconnectOverlay").classList.remove("active"); });

</script>
</body>
</html>
