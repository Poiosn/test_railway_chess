<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Chess Master ‚Äî Premium Edition</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
  <style>
    /* static/style.css content embedded */
    * { margin:0; padding:0; box-sizing:border-box; }

    /* STATIC LIGHT SKY BLUE BACKGROUND */
    body {
      font-family:'Inter','Segoe UI','Helvetica Neue',sans-serif;
      background: #87CEEB;
      min-height:100vh;
      display:flex;
      justify-content:center;
      align-items:center;
      padding:20px;
      position:relative;
      overflow-x:hidden;
    }

    /* GLASSMORPHISM CONTAINER */
    .container{
      background: rgba(255, 255, 255, 0.25);
      backdrop-filter: blur(20px) saturate(180%);
      -webkit-backdrop-filter: blur(20px) saturate(180%);
      border: 1px solid rgba(255, 255, 255, 0.3);
      border-radius: 32px;
      box-shadow: 
        0 8px 32px 0 rgba(31, 38, 135, 0.37),
        inset 0 1px 0 0 rgba(255, 255, 255, 0.5);
      padding:28px;
      width:90vw;
      max-width:1500px;
      height:auto;
      max-height:92vh;
      position:relative;
      z-index:1;
      overflow-y:auto;
      animation: containerFadeIn 0.6s ease;
    }

    @keyframes containerFadeIn {
      from { opacity: 0; transform: translateY(20px); }
      to { opacity: 1; transform: translateY(0); }
    }

    h1 {
      text-align:center;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 50%, #f093fb 100%);
      background-size: 200% auto;
      -webkit-background-clip:text;
      -webkit-text-fill-color:transparent;
      background-clip:text;
      font-size:36px;
      font-weight:900;
      margin-bottom:8px;
      letter-spacing:-1.5px;
      animation: titleShine 3s linear infinite;
      text-shadow: 0 0 30px rgba(102, 126, 234, 0.3);
    }

    @keyframes titleShine {
      to { background-position: 200% center; }
    }

    .subtitle {
      text-align:center;
      color:#555;
      margin-bottom:14px;
      font-size:13px;
      font-weight:500;
      letter-spacing: 0.5px;
    }

    .connection-status {
      text-align:center;
      padding:10px 20px;
      margin-bottom:12px;
      border-radius:16px;
      font-weight:700;
      font-size:13px;
      transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: 0 4px 15px rgba(0,0,0,0.1);
    }
    .connection-status.connected {
      background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
      color: white;
      animation: pulse 2s ease-in-out infinite;
    }
    .connection-status.disconnected {
      background: linear-gradient(135deg, #eb3349 0%, #f45c43 100%);
      color: white;
    }

    @keyframes pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.02); }
    }

    .game-info {
      text-align:center;
      margin-bottom: 20px;
      padding:16px;
      background: rgba(255, 255, 255, 0.6);
      backdrop-filter: blur(10px);
      border-radius:16px;
      border: 1px solid rgba(255, 255, 255, 0.8);
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.1);
      transition: transform 0.3s ease;
    }
    .game-info h3 {
      font-size: 18px;
      font-weight: 800;
      color: #333;
      margin-bottom: 8px;
    }

    .player-badge {
      padding: 6px 16px;
      border-radius: 20px;
      font-weight: 800;
      font-size: 14px;
      display: inline-block;
      transition: all 0.3s ease;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.15);
    }
    .player-badge.white {
      background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
      border: 2px solid #e0e0e0;
      color: #333;
    }
    .player-badge.black {
      background: linear-gradient(135deg, #434343 0%, #000000 100%);
      color: #fff;
      border: 2px solid #666;
    }

    .timer {
      padding: 8px 16px;
      border-radius: 12px;
      text-align: center;
      font-size: 16px;
      font-weight: 800;
      transition: all 0.3s ease;
      position: absolute;
      backdrop-filter: blur(10px);
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
      min-width: 80px;
      z-index: 10; 
    }
    .timer.white {
      background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
      border: 2px solid #e0e0e0;
      color: #333;
    }
    .timer.black {
      background: linear-gradient(135deg, #434343 0%, #000000 100%);
      color: #fff;
      border: 2px solid #666;
    }
    .timer.active {
      box-shadow: 0 0 30px rgba(102, 126, 234, 0.8), 0 4px 15px rgba(0, 0, 0, 0.3);
      transform: scale(1.08);
      animation: timerPulse 1.5s ease-in-out infinite;
    }

    @keyframes timerPulse {
      0%, 100% { transform: scale(1.08); }
      50% { transform: scale(1.12); }
    }

    .board-section {
      position: relative;
      width: 100%;
      max-width: 700px;
      margin: 0 auto;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .chessboard {
      display: grid;
      grid-template-columns: repeat(8, 1fr);
      width: min(92vw, 700px);
      aspect-ratio: 1 / 1;
      height: auto;
      border: 6px solid rgba(44, 62, 80, 0.8);
      border-radius: 12px;
      overflow: hidden;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4), inset 0 1px 0 rgba(255, 255, 255, 0.2);
      position: relative;
      transform-style: preserve-3d;
      perspective: 1000px;
    }

    .square {
      aspect-ratio: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      position: relative;
      overflow: hidden;
    }
    .square.light { background: linear-gradient(135deg, #f5e6d3 0%, #f0d9b5 100%); }
    .square.dark { background: linear-gradient(135deg, #c9a882 0%, #b58863 100%); }
    .square.selected {
      background: radial-gradient(circle, #baca44 0%, #a8b834 100%) !important;
      box-shadow: inset 0 0 30px rgba(0, 0, 0, 0.4);
    }
    .square.possible-move::after {
      content: '';
      position: absolute;
      width: 35%;
      height: 35%;
      background: radial-gradient(circle, rgba(34, 197, 94, 0.6), rgba(34, 197, 94, 0.3));
      border-radius: 50%;
    }
    .square.last-move {
      background: radial-gradient(circle, #ffd93d 0%, #cdd26a 100%) !important;
    }

    .piece {
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: grab;
    }
    .piece img {
      width: 88%;
      height: 88%;
      object-fit: contain;
      pointer-events: none;
      filter: drop-shadow(0 2px 8px rgba(0, 0, 0, 0.3));
    }

    .coordinates {
      position: absolute;
      font-size: 12px;
      font-weight: 800;
      color: #2c3e50;
      pointer-events: none;
      text-shadow: 0 1px 2px rgba(255, 255, 255, 0.8);
    }
    .coord-file { bottom: -28px; left: 0; width: 100%; display: flex; justify-content: space-between; padding: 0 8px; }
    .coord-rank { top: 0; height: 100%; left: -32px; display: flex; flex-direction: column; justify-content: space-between; }
    .coord-file.flipped { top: -24px; bottom: auto; }
    .coord-rank.flipped { left: auto; right: -28px; }

    .move-history {
      background: rgba(255, 255, 255, 0.6);
      backdrop-filter: blur(10px);
      border-radius: 16px;
      padding: 14px;
      height: 600px;
      overflow-y: auto;
      border: 1px solid rgba(255, 255, 255, 0.8);
    }
    .move-list {
      display: grid;
      grid-template-columns: 45px 1fr 1fr;
      gap: 10px;
      font-size: 14px;
      margin-top: 10px;
    }
    .move-number { color: #666; font-weight: 800; text-align: right; }
    .move-item {
      background: rgba(248, 249, 250, 0.8);
      padding: 6px 10px;
      border-radius: 8px;
      text-align: center;
    }

    /* MODALS & CHAT (Styles abbreviated for length, functionally same) */
    .promotion-modal, .draw-modal {
      position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
      display: none; align-items: center; justify-content: center;
      background: rgba(0, 0, 0, 0.7); z-index: 9999;
    }
    .promotion-modal.active, .draw-modal.active { display: flex; }
    .promotion-content, .draw-content {
      background: white; padding: 28px; border-radius: 20px; text-align: center;
    }
    .chat-box {
      background: rgba(255, 255, 255, 0.6); padding: 12px; border-radius: 16px;
    }
    .chat-messages { height: 220px; overflow-y: auto; display: flex; flex-direction: column; gap: 8px; }
    .chat-line { padding: 8px 12px; border-radius: 10px; max-width: 85%; font-size: 13px; }
    .chat-line.you { background: #667eea; color: white; align-self: flex-end; }
    .chat-line.opponent { background: #667eea; color: white; align-self: flex-start; }
    
    .button-group { display: flex; justify-content: center; gap: 14px; margin-top: 20px; flex-wrap: wrap; }
    button { padding: 14px 24px; border-radius: 14px; border:none; color:white; font-weight:700; cursor:pointer; background: #667eea; }
    .btn-danger { background: #eb3349; }
    .btn-draw { background: #f7971e; }
    .btn-secondary { background: #bdc3c7; }

    .waiting-overlay {
      position: absolute; top:0;left:0;right:0;bottom:0; background:rgba(0,0,0,0.6); 
      z-index:100; display:flex; flex-direction:column; align-items:center; justify-content:center; color:white;
    }
    .disconnect-overlay {
      position: absolute; top:0;left:0;right:0;bottom:0; background:rgba(220, 38, 38, 0.8);
      z-index:101; display:none; flex-direction:column; align-items:center; justify-content:center; color:white;
    }
    .disconnect-overlay.active { display: flex; }

    /* ========================================
       MOBILE RESPONSIVE ENHANCEMENTS (UPDATED)
       ======================================== */
    @media (max-width: 900px) {
      body { padding: 10px; }
      .container { padding: 16px; border-radius: 20px; }
      .game-layout { flex-direction: column !important; gap: 14px !important; }
      .sidebar { width: 100% !important; }

      /* === HIDE HISTORY === */
      .move-history { display: none !important; }

      /* === FIX TIMER OVERLAP === */
      .board-section {
        /* Add margin to top to prevent timer overlapping Room Header */
        margin-top: 50px !important; 
        margin-bottom: 20px;
      }

      /* Move Timers to LEFT SIDE and adjust vertical position */
      #blackTimer {
        top: -40px !important;       /* Sit just above board */
        left: 0 !important;          /* Align to Left edge */
        transform: none !important;  /* Remove centering */
        padding: 6px 12px !important;
        font-size: 13px !important;
      }

      #whiteTimer {
        bottom: -40px !important;    /* Sit just below board */
        left: 0 !important;          /* Align to Left edge */
        transform: none !important;  /* Remove centering */
        padding: 6px 12px !important;
        font-size: 13px !important;
      }

      .coord-file { bottom: -22px !important; font-size: 10px !important; }
      .coord-rank { left: -24px !important; font-size: 10px !important; }
    }
  </style>
</head>

<body>

<div id="soundToggle" class="sound-toggle" onclick="toggleSound()" title="Toggle Sound">üîä</div>

<div class="container">

    <h1>‚ôî Chess Master ‚ôö</h1>
    <p class="subtitle">‚ö° Premium Edition ‚Äî Real-time Multiplayer</p>
    
    <div id="loadingMessage" style="text-align:center; padding:40px; font-weight:bold; color:#333;">
        <div style="font-size:24px; margin-bottom:10px;">üîå</div>
        Connecting to server...
    </div>

    <div id="game" style="display:none;">
      <div class="game-info">
        <h3>üë• Room: <span id="roomName"></span></h3>
        <p>You are playing as: <span id="playerColorBadge"></span></p>
      </div>

      <div class="game-layout" style="display:flex; gap:40px; align-items:flex-start;">
        <div class="board-section">
          
          <div id="blackTimer" class="timer black" style="left:0px;">5:00</div>
          <div id="whiteTimer" class="timer white" style="left:0px;">5:00</div>

          <div class="turn-indicator" id="turnIndicator"></div>

          <div class="board-wrapper" style="position:relative;" id="boardWrapper">
            <div class="chessboard" id="chessboard"></div>
            <div class="coordinates coord-file" id="coordFiles"></div>
            <div class="coordinates coord-rank" id="coordRanks"></div>
            
            <div id="waitingOverlay" class="waiting-overlay" style="display:none;">
               <div class="waiting-spinner" style="border:4px solid rgba(255,255,255,0.3);border-top:4px solid #fff;border-radius:50%;width:40px;height:40px;animation:spin 1s linear infinite;margin-bottom:15px;"></div>
               <div>Waiting for opponent...</div>
            </div>

            <div id="disconnectOverlay" class="disconnect-overlay">
                <div style="font-size:24px;margin-bottom:10px;">‚ö†Ô∏è</div>
                <div style="font-size:18px; margin-bottom:8px;">Opponent Disconnected</div>
                <div style="font-size:14px;">Claiming win in <span id="disconnectTimer">15</span>s...</div>
            </div>
          </div>

          <div class="status" id="status"></div>
          <div class="messages" id="messages"></div>
        </div>
        
        <div class="sidebar" style="display:flex; gap:20px;">

          <div class="move-history" style="flex:1;">
            <h4>üìú Move History</h4>
            <div class="move-list" id="moveList"></div>
          </div>

          <div class="chat-box" id="chatBox" style="flex:1;">
            <h4>üí¨ Live Chat</h4>
            <div class="chat-messages" id="chatMessages" style="height:500px;"></div>
            <div class="typing-indicator" id="typingIndicator"></div>

            <div class="chat-input" style="margin-top:10px; position:relative;">
              <div style="display:flex;align-items:center;gap:8px;">
                <input id="chatInput" type="text" placeholder="Type your message..." />
                <button onclick="sendChat()">Send</button>
              </div>
            </div>
          </div>

        </div>
      </div>

      <div class="button-group">
        <button onclick="goHome()">üè† Home</button>
        <button onclick="offerDraw()" class="btn-draw">ü§ù Offer Draw</button>
        <button onclick="resignGame()" class="btn-danger">üè≥Ô∏è Resign</button>
      </div>

    </div>
</div>

<div class="promotion-modal" id="promotionModal" aria-hidden="true">
  <div class="promotion-content">
    <h3>üëë Promote Your Pawn</h3>
    <p style="color:#666;margin-top:8px;">Choose a piece:</p>
    <div class="promotion-pieces" id="promotionPieces"></div>
    <div style="margin-top:16px;">
      <button onclick="cancelPromotion()" class="btn-secondary">Cancel</button>
    </div>
  </div>
</div>

<div class="draw-modal" id="drawModal" aria-hidden="true">
  <div class="draw-content">
    <h3>ü§ù Draw Offer</h3>
    <p id="drawMessage" style="color:#666;margin-top:12px;font-size:15px;"></p>
    <div style="margin-top:16px;display:flex;gap:12px;justify-content:center;">
      <button onclick="respondToDraw(true)" class="btn-primary">‚úÖ Accept</button>
      <button onclick="respondToDraw(false)" class="btn-danger">‚ùå Decline</button>
    </div>
  </div>
</div>

<script>
const socket = io({ 
  transports: ["websocket", "polling"],
  reconnection: true
});

const params = new URLSearchParams(window.location.search);
const URL_ROOM = params.get('room');
const URL_NAME = params.get('name');
const URL_MODE = params.get('mode');
const URL_TIME = params.get('time');

if (!URL_ROOM || !URL_NAME) {
    alert("Invalid parameters.");
    window.location.href = "/";
}

let currentRoom = URL_ROOM;
let playerColor = null;
let playerName = URL_NAME;
let gameState = null;
let selectedSquare = null;
let possibleMoves = [];
let pendingPromotion = null;
let moveHistory = [];
let soundEnabled = true;
let lastMoveWasMine = false;
let whiteSeconds = 0;
let blackSeconds = 0;
let timerInterval = null;
let disconnectInterval = null;

// Timer Positioning
function updateTimerPositions(myColor) {
    const whiteTimer = document.getElementById("whiteTimer");
    const blackTimer = document.getElementById("blackTimer");

    whiteTimer.style.top = ""; whiteTimer.style.bottom = "";
    blackTimer.style.top = ""; blackTimer.style.bottom = "";

    if (myColor === 'black') {
        // I am Black (Bottom).
        whiteTimer.style.top = "-34px"; 
        blackTimer.style.bottom = "-34px";
    } else {
        // I am White (Bottom).
        whiteTimer.style.bottom = "-34px"; 
        blackTimer.style.top = "-34px";
    }
}

function formatSeconds(sec) {
  sec = Math.max(0, Math.floor(sec));
  const m = Math.floor(sec / 60);
  const s = sec % 60;
  return `${m}:${s.toString().padStart(2, "0")}`;
}

function updateDisplayedTimers() {
  const w = document.getElementById("whiteTimer");
  const b = document.getElementById("blackTimer");
  if (w) w.textContent = formatSeconds(whiteSeconds);
  if (b) b.textContent = formatSeconds(blackSeconds);
  
  if (gameState && !gameState.winner) {
    if (w) w.classList.toggle("active", gameState.turn === "white");
    if (b) b.classList.toggle("active", gameState.turn === "black");
  } else {
    if (w) w.classList.remove("active");
    if (b) b.classList.remove("active");
  }
}

function startLocalTimer() {
  if (timerInterval) clearInterval(timerInterval);
  timerInterval = setInterval(() => {
    if (!gameState || gameState.winner || gameState.isActive === false) return;
    if (gameState.turn === "white" && whiteSeconds > 0) whiteSeconds--;
    else if (gameState.turn === "black" && blackSeconds > 0) blackSeconds--;
    updateDisplayedTimers();
  }, 1000);
}

const sounds = { move: {f:400,d:0.1}, capture: {f:300,d:0.15}, check: {f:600,d:0.2}, win: {f:800,d:0.3}, notify: {f:500,d:0.1} };
function playSound(type) {
  if (!soundEnabled) return;
  try {
    const ctx = new (window.AudioContext || window.webkitAudioContext)();
    const osc = ctx.createOscillator();
    const g = ctx.createGain();
    osc.connect(g); g.connect(ctx.destination);
    osc.frequency.value = sounds[type].f;
    g.gain.setValueAtTime(0.3, ctx.currentTime);
    g.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + sounds[type].d);
    osc.start(); osc.stop(ctx.currentTime + sounds[type].d);
  } catch (e) {}
}

function toggleSound(){
  soundEnabled = !soundEnabled;
  const btn = document.getElementById("soundToggle");
  if(btn) btn.textContent = soundEnabled ? "üîä" : "üîá";
}

function sendChat(){
  const input = document.getElementById("chatInput");
  const text = input ? input.value.trim() : "";
  if(!text) return;
  socket.emit("send_message", { room: currentRoom, sender: playerColor, message: text, senderName: playerName });
  input.value = "";
}

function appendChat(data, isLocal){
  const box = document.getElementById("chatMessages");
  if (!box) return;
  const div = document.createElement("div");
  div.className = "chat-line " + (isLocal ? "you" : "opponent");
  div.innerText = `${data.senderName || data.sender}: ${data.message}`;
  box.appendChild(div);
  box.scrollTop = box.scrollHeight;
}

// SOCKETS
socket.on("connect",()=>{
  if (URL_MODE === 'create') socket.emit("create_room", { room: URL_ROOM, timeControl: URL_TIME, playerName: URL_NAME, bot: false });
  else if (URL_MODE === 'join') socket.emit("join_room", { room: URL_ROOM, playerName: URL_NAME });
  else if (URL_MODE === 'bot') socket.emit("create_room", { room: URL_ROOM, timeControl: URL_TIME, playerName: URL_NAME, bot: true });
});

socket.on("room_created", startGame);
socket.on("room_joined", startGame);
socket.on("error", (data) => { alert(data.message); window.location.href = "/"; });

function startGame(data){
  document.getElementById("loadingMessage").style.display = "none";
  document.getElementById("game").style.display = "block";
  currentRoom = data.room;
  playerColor = data.color;
  gameState = data.state;
  updateTimerPositions(playerColor);

  document.getElementById("roomName").textContent = currentRoom;
  document.getElementById("playerColorBadge").innerHTML = `<span class="player-badge ${playerColor}">${playerColor.toUpperCase()} ‚Äî ${playerName}</span>`;

  whiteSeconds = gameState.whiteTimeFormatted ? timeStringToSeconds(gameState.whiteTimeFormatted) : (URL_TIME || 300);
  blackSeconds = gameState.blackTimeFormatted ? timeStringToSeconds(gameState.blackTimeFormatted) : (URL_TIME || 300);
  updateDisplayedTimers();

  const isWaiting = (gameState.isActive === false);
  document.getElementById("waitingOverlay").style.display = isWaiting ? "flex" : "none";
  if (!isWaiting) startLocalTimer();

  renderBoard(gameState);
  updateStatus(gameState);
  updateTurnIndicator(gameState);
}

socket.on("game_start", d=>{
  gameState = d.state;
  document.getElementById("waitingOverlay").style.display = "none";
  startLocalTimer();
  renderBoard(gameState);
  updateStatus(gameState);
  updateTurnIndicator(gameState);
  playSound("notify");
});

socket.on("game_update", d => {
  const prev = gameState;
  gameState = d.state;

  if (gameState.whiteTimeFormatted) whiteSeconds = timeStringToSeconds(gameState.whiteTimeFormatted);
  if (gameState.blackTimeFormatted) blackSeconds = timeStringToSeconds(gameState.blackTimeFormatted);
  updateDisplayedTimers();
  
  if (gameState.winner) {
      document.getElementById("disconnectOverlay").classList.remove("active");
      if (disconnectInterval) clearInterval(disconnectInterval);
  }

  if (d.lastMove) addMoveToHistory(d.lastMove, d.moveNotation);
  renderBoard(gameState, d.lastMove);
  updateStatus(gameState);
  updateTurnIndicator(gameState);

  if (prev && !prev.winner && (gameState.check || d.lastMove)) {
     if(gameState.winner) playSound("win");
     else if(gameState.check) playSound("check");
     else {
       const capture = prev.board[d.lastMove.to.row][d.lastMove.to.col] !== ".";
       playSound(capture ? "capture" : "move");
     }
  }
});

socket.on("player_disconnected", (data) => {
    if (data.color !== playerColor) {
        const ov = document.getElementById("disconnectOverlay");
        const ts = document.getElementById("disconnectTimer");
        let t = data.timeout || 15;
        ov.classList.add("active");
        ts.textContent = t;
        if (disconnectInterval) clearInterval(disconnectInterval);
        disconnectInterval = setInterval(() => { t--; ts.textContent = t; if (t<=0) clearInterval(disconnectInterval); }, 1000);
    }
});
socket.on("player_reconnected", () => {
    document.getElementById("disconnectOverlay").classList.remove("active");
    if (disconnectInterval) clearInterval(disconnectInterval);
});

socket.on("chat_message", data => { appendChat(data, data.sender === playerColor); if(data.sender!==playerColor) playSound("notify"); });
socket.on("invalid_move", () => { 
  const m = document.getElementById("messages"); if(m) m.textContent = "‚ùå Invalid move!"; 
  renderBoard(gameState); // Revert drag
});

document.getElementById("chatInput").addEventListener("keydown", (e)=>{ if(e.key==="Enter") sendChat(); });

// BOARD RENDERING
function renderBoard(state, lastMove=null){
  const board=document.getElementById("chessboard");
  if (!board) return;
  board.innerHTML="";
  const flipped = (playerColor === "black");
  const rows = flipped ? [...Array(8).keys()].reverse() : [...Array(8).keys()];
  const cols = flipped ? [...Array(8).keys()].reverse() : [...Array(8).keys()];

  for (let r of rows){
    for (let c of cols){
      const sq=document.createElement("div");
      sq.className=`square ${(r+c)%2===0?"light":"dark"}`;
      sq.dataset.row=r; sq.dataset.col=c;
      if(lastMove && ((lastMove.from.row===r && lastMove.from.col===c)||(lastMove.to.row===r && lastMove.to.col===c))) sq.classList.add("last-move");
      if(selectedSquare && selectedSquare.row===r && selectedSquare.col===c) sq.classList.add("selected");
      if(possibleMoves.some(m=>m.row===r && m.col===c)) sq.classList.add("possible-move");

      const piece = state.board[r][c];
      if(piece !== "."){
        const pDiv=document.createElement("div");
        pDiv.className="piece";
        const isWhite = piece === piece.toUpperCase();
        const myPiece = (playerColor==="white" && isWhite) || (playerColor==="black" && !isWhite);
        
        if(state.turn === (isWhite?"white":"black") && myPiece) pDiv.draggable=true;
        
        // DRAG HANDLERS
        pDiv.addEventListener("dragstart", e=>{
          selectedSquare = { row:r, col:c };
          const key = `${r},${c}`;
          // Use pre-loaded moves if available (from backend optimization)
          if(state.moves && state.moves[key]) possibleMoves = state.moves[key];
          
          // Manual highlight (no full re-render)
          document.querySelectorAll('.square').forEach(s=>s.classList.remove('selected','possible-move'));
          sq.classList.add('selected');
          possibleMoves.forEach(m=>{
             const t=document.querySelector(`.square[data-row="${m.row}"][data-col="${m.col}"]`);
             if(t) t.classList.add('possible-move');
          });
          e.dataTransfer.setData("fromRow", r); e.dataTransfer.setData("fromCol", c);
        });

        pDiv.addEventListener("dragend", ()=> renderBoard(gameState, lastMove));

        const img=document.createElement("img");
        const clr = isWhite ? "w" : "b";
        img.src=`https://images.chesscomfiles.com/chess-themes/pieces/neo/150/${clr}${piece.toLowerCase()}.png`;
        pDiv.appendChild(img);
        sq.appendChild(pDiv);
      }
      sq.addEventListener("click", ()=> handleSquareClick(r,c,state));
      sq.addEventListener("dragover", e=>e.preventDefault());
      sq.addEventListener("drop", e=>{
        e.preventDefault();
        const fr=parseInt(e.dataTransfer.getData("fromRow"));
        const fc=parseInt(e.dataTransfer.getData("fromCol"));
        if(isNaN(fr)) return;
        const valid = possibleMoves.some(m=>m.row===r && m.col===c);
        if(!valid) { document.getElementById("messages").textContent="‚ùå Invalid move!"; return; }
        checkPromotionAndMove({row:fr,col:fc}, {row:r,col:c}, state);
      });
      board.appendChild(sq);
    }
  }
  
  const f=document.getElementById("coordFiles");
  const rEl=document.getElementById("coordRanks");
  const files = playerColor==="black" ? ["h","g","f","e","d","c","b","a"] : ["a","b","c","d","e","f","g","h"];
  const ranks = playerColor==="black" ? ["1","2","3","4","5","6","7","8"] : ["8","7","6","5","4","3","2","1"];
  if(f) f.innerHTML = files.map(x=>`<span>${x}</span>`).join("");
  if(rEl) rEl.innerHTML = ranks.map(x=>`<span>${x}</span>`).join("");
}

function handleSquareClick(row, col, state){
  if(state.winner || state.isActive===false) return;
  const piece = state.board[row][col];
  const isWhite = piece !== "." && piece === piece.toUpperCase();
  const isMine = piece !== "." && ((playerColor==="white" && isWhite) || (playerColor==="black" && !isWhite));

  if(isMine){
    selectedSquare = { row,col };
    const key = `${row},${col}`;
    possibleMoves = (state.moves && state.moves[key]) ? state.moves[key] : [];
    renderBoard(state);
    return;
  }
  if(!selectedSquare) return;
  const valid = possibleMoves.some(m=>m.row===row && m.col===col);
  if(!valid) { document.getElementById("messages").textContent="‚ùå Invalid move!"; return; }
  checkPromotionAndMove(selectedSquare, {row,col}, state);
}

function checkPromotionAndMove(from, to, state){
  const piece = state.board[from.row][from.col];
  const isPawn = piece.toLowerCase()==="p";
  const isPromo = (playerColor==="white" && to.row===0) || (playerColor==="black" && to.row===7);
  
  if(isPawn && isPromo){
    pendingPromotion = { from, to };
    showPromotionModal(playerColor);
  } else {
    makeMove(from, to);
  }
}

function makeMove(from, to, promotion=null){
  const moveId = ++moveSequence;
  socket.emit("move", { room: currentRoom, from, to, promotion, moveId });
  
  // Optimistic Update
  const p = JSON.parse(JSON.stringify(gameState));
  const pc = p.board[from.row][from.col];
  p.board[to.row][to.col] = promotion ? (playerColor==="white"?promotion.toUpperCase():promotion) : pc;
  p.board[from.row][from.col] = ".";
  p.turn = (p.turn==="white"?"black":"white");
  renderBoard(p, {from, to});
  
  selectedSquare=null; possibleMoves=[];
}

function showPromotionModal(c){
  const m=document.getElementById("promotionModal");
  const p=document.getElementById("promotionPieces");
  p.innerHTML="";
  ['q','r','b','n'].forEach(t=>{
    const i=document.createElement("img");
    i.src=`https://images.chesscomfiles.com/chess-themes/pieces/neo/150/${c==="white"?"w":"b"}${t}.png`;
    i.onclick=()=>{ makeMove(pendingPromotion.from, pendingPromotion.to, t); m.classList.remove("active"); };
    p.appendChild(i);
  });
  m.classList.add("active");
}
function cancelPromotion(){ document.getElementById("promotionModal").classList.remove("active"); pendingPromotion=null; }

function addMoveToHistory(m, san){
  moveHistory.push({from:m.from, to:m.to, notation:san});
  renderMoveHistory();
}
function renderMoveHistory(){
  const l=document.getElementById("moveList");
  l.innerHTML="";
  for(let i=0;i<moveHistory.length;i+=2){
    const n=document.createElement("div"); n.className="move-number"; n.textContent=(i/2+1)+"."; l.appendChild(n);
    const w=document.createElement("div"); w.className="move-item white"; w.textContent=moveHistory[i].notation; l.appendChild(w);
    if(i+1<moveHistory.length){
       const b=document.createElement("div"); b.className="move-item black"; b.textContent=moveHistory[i+1].notation; l.appendChild(b);
    } else l.appendChild(document.createElement("div"));
  }
  l.parentElement.scrollTop = l.parentElement.scrollHeight;
}

function updateTurnIndicator(s){
  const i=document.getElementById("turnIndicator");
  if(s.winner) { i.textContent="üèÅ Game Over"; i.style.background="#11998e"; i.style.color="white"; return; }
  i.textContent = (s.turn==="white") ? "‚ôî White to move" : "‚ôö Black to move";
  i.style.background=""; i.style.color="";
}
function updateStatus(s){
  const el=document.getElementById("status");
  if(s.winner) { el.textContent=`üëë ${s.winner.toUpperCase()} Wins!`; el.style.background="#11998e"; el.style.color="white"; }
  else if(s.check) { el.textContent="‚ö†Ô∏è CHECK!"; el.style.background="#eb3349"; el.style.color="white"; }
  else { el.textContent=""; el.style.background=""; }
}

function goHome(){ if(confirm("Quit game?")) { socket.emit("leave_room",{room:currentRoom}); window.location.href="/"; } }
function offerDraw(){ socket.emit("offer_draw",{room:currentRoom,color:playerColor}); document.getElementById("messages").textContent="Draw offered..."; }
socket.on("draw_offered", d=>{ 
  document.getElementById("drawMessage").textContent = `${d.fromColor} offers draw.`;
  document.getElementById("drawModal").classList.add("active"); 
});
socket.on("draw_declined", ()=>document.getElementById("messages").textContent="Draw declined.");
function respondToDraw(a){ socket.emit("respond_draw",{room:currentRoom,accept:a}); document.getElementById("drawModal").classList.remove("active"); }
function resignGame(){ if(confirm("Resign?")) socket.emit("resign",{room:currentRoom,color:playerColor}); }
</script>
</body>
</html>
